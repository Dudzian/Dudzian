# Przegląd stanu bota handlowego – warstwy runtime i UI

## Co już działa
- **Strumieniowanie long-poll** – adaptery giełdowe korzystają z neutralnego interfejsu `MarketStreamHandle` i klas bazowych REST, dzięki czemu eliminują zależności po WebSocketach i zachowują zgodność z menedżerem giełd.【F:bot_core/exchanges/interfaces.py†L1-L105】【F:bot_core/exchanges/streaming.py†L1-L168】
- **Autonomiczny AutoTrader** – publiczne API `run_decision_cycle()` deleguje do pętli decyzyjnej, integrując klasyfikator reżimów, orkiestrator decyzji, dziennik audytu i usługę egzekucji, a nowe testy E2E korzystają z raportu metryk w scenariuszach paper/live z udaną i nieudaną egzekucją.【F:bot_core/auto_trader/app.py†L8400-L8610】【F:tests/e2e/test_autotrader_autonomy.py†L1-L200】【F:tests/e2e/fixtures/execution.py†L1-L80】
- **UI runtime** – `RuntimeService` udostępnia QML-owi znormalizowane wpisy `TradingDecisionJournal`, agreguje metryki ryzyka (`riskMetrics`, `riskTimeline`, `lastOperatorAction`) i zasila karty „Decyzje AI” oraz panel „Risk Journal” z drill-downem, akcjami operatora, podsumowaniem ostatniej interwencji i histogramami najczęstszych flag/stress failure.【F:ui/backend/runtime_service.py†L1-L520】【F:ui/qml/dashboard/RuntimeOverview.qml†L1-L420】
- **gRPC decision journal** – serwis `RuntimeService.ListDecisions` udostępnia filtrowalne okno `TradingDecisionJournal` (limit, kursor, filtry po strategii/symbolu/statusie oraz przedział czasowy), co pozwala backendowi i narzędziom audytowym pobierać wpisy bezpośrednio z procesu runtime.【F:proto/trading.proto†L205-L286】【F:bot_core/api/server.py†L1470-L1606】
- **Metryki cyklu decyzyjnego** – `ListDecisions` i `StreamDecisions` dołączają mapę metryk (`cycles_total`, `strategy_switch_total`, `guardrail_blocks_total`) oraz opcjonalne opóźnienia `cycle_latency_p50_ms`/`cycle_latency_p95_ms`, a `RuntimeService` eksponuje je w QML jako panel „Metryki cyklu decyzyjnego”.【F:proto/trading.proto†L225-L314】【F:bot_core/api/server.py†L1460-L1580】【F:ui/backend/runtime_service.py†L720-L1180】【F:ui/qml/dashboard/RuntimeOverview.qml†L560-L700】
- **SLO feedu gRPC** – `RuntimeService` preferuje gRPC, automatycznie planując reconnect po fallbacku, i zapisuje kompletny snapshot (`downtimeMs`, `nextRetrySeconds`, `p95_ms`, `p95_seconds`) do `reports/ci/decision_feed_metrics.json`, który testy oraz job CI asertywnie weryfikują (p95 ≤3 s).【F:ui/backend/runtime_service.py†L600-L1480】【F:tests/integration/test_grpc_transport.py†L230-L320】【F:.github/workflows/ci.yml†L360-L420】
- **Fallback long-poll** – `LocalLongPollStream.export_metrics_snapshot()` rejestruje latencje p50/p95, błędy HTTP i reconnecty, cache `ui_metrics.long_poll_snapshots` publikuje je do UI, a panel „Fallback long-poll” wizualizuje kondycję każdego adaptera.【F:bot_core/exchanges/streaming.py†L150-L420】【F:bot_core/observability/ui_metrics.py†L1-L200】【F:ui/backend/runtime_service.py†L600-L990】【F:ui/qml/dashboard/RuntimeOverview.qml†L640-L760】

## Najważniejsze luki
- **Alerty SLA dla feedu** – `feedHealth` udostępnia surowe metryki long-polla, ale brak progów i eskalacji (np. sygnałów degradacji do HyperCare), przez co operatorzy muszą ręcznie interpretować dane.【F:ui/backend/runtime_service.py†L600-L820】【F:ui/qml/dashboard/RuntimeOverview.qml†L640-L760】
- **Marketplace presetów** – benchmark nadal wskazuje brak publicznego katalogu oraz procesu publikacji presetów, co blokuje dystrybucję konfiguracji dla użytkowników końcowych.【F:docs/benchmark/cryptohopper_comparison.md†L24-L37】【F:docs/benchmark/cryptohopper_comparison.md†L65-L97】
- **Monitoring futures** – adaptery Deribit/BitMEX zostały wdrożone, ale wymagają automatycznego monitoringu HyperCare (raporty `scripts/list_exchange_adapters.py`, alerty long-polla) oraz cyklicznej walidacji podpisanych checklist.【F:scripts/list_exchange_adapters.py†L1-L150】【F:docs/benchmark/cryptohopper_comparison.md†L65-L90】

### Konfiguracja środowiska runtime
- `BOT_CORE_UI_GRPC_ENDPOINT` / `BOT_CORE_TRADING_GRPC_ADDRESS` – adres serwera gRPC, z którego RuntimeService pobiera dziennik decyzji. Pierwsza zmienna ma najwyższy priorytet i pozwala na wskazanie lokalnego stubu lub tunelu SSH podczas diagnostyki.【F:ui/backend/runtime_service.py†L780-L820】
- `BOT_CORE_UI_FEED_LATENCY_PATH` – ścieżka do pliku JSON z metrykami kanału (latencja p50/p95, `p95_seconds`, licznik reconnectów, `downtimeMs`, `nextRetrySeconds`). Jeśli nie zostanie ustawiona, raport trafia do `reports/ci/decision_feed_metrics.json` i jest zbierany przez pipeline CI.【F:ui/backend/runtime_service.py†L610-L1420】【F:tests/integration/test_grpc_transport.py†L228-L320】
- `BOT_CORE_UI_GRPC_RETRY_LIMIT` – liczba nieudanych prób nawiązania strumienia gRPC, po której UI przełącza się na fallback JSONL. Domyślnie 3, co umożliwia krótką degradację bez utraty gRPC w przypadku chwilowych zakłóceń.【F:ui/backend/runtime_service.py†L598-L640】
- `BOT_CORE_UI_GRPC_RETRY_BASE_SECONDS`, `BOT_CORE_UI_GRPC_RETRY_MULTIPLIER`, `BOT_CORE_UI_GRPC_RETRY_MAX_SECONDS` – parametry backoffu wykorzystywane przez wątek `_grpc_worker`. Pozwalają kontrolować interwały autoreconnectu (bazowy czas, mnożnik wykładniczy oraz maksymalny limit).【F:ui/backend/runtime_service.py†L912-L1005】
- `BOT_CORE_UI_GRPC_READY_TIMEOUT` – czas (w sekundach), jaki UI czeka na gotowość kanału gRPC (`grpc.channel_ready_future`). Po przekroczeniu limitu próba uznawana jest za nieudaną i trafia w mechanizm backoffu.【F:ui/backend/runtime_service.py†L889-L954】

### Etap CI `ui-tests`
- Job `ui-tests` zależy od `prepare-pyside6-wheel`, pobiera wstępnie zbudowane wheel’e PySide6 i instaluje je wraz z zależnościami `.[dev]`, aby uruchomić `pytest -m qml` na platformie `offscreen` (Qt Quick Software).【F:.github/workflows/ci.yml†L220-L310】
- Testy generują artefakt `test-results/qml`, który zawiera logi Qt (`logs/*.log`), manifest JSON z wynikami (`manifest.json`) oraz katalog `screenshots/` na przyszłe raporty wizualne, co ułatwia analizę niepowodzeń UI bez dostępu do środowiska graficznego.【F:tests/ui/conftest.py†L1-L190】

### Wymagania danych dla Risk Journal
- wpisy dziennika powinny uzupełniać pola `risk_flags`, `stress_failures` oraz `stress_overrides` (lista powodów) lub `risk_action`, aby panel mógł policzyć blokady, zamrożenia, podświetlić stress overrides, policzyć histogramy strategii/flag/stress failure, wskazać ostatnią blokadę/zamrożenie/override oraz poprawnie opisać ostatnią akcję operatora; brak tych pól skutkuje pustym wykresem, filtrami bez wartości oraz pustymi żetonami statystyk.【F:ui/backend/runtime_service.py†L200-L460】【F:ui/qml/dashboard/RiskJournalPanel.qml†L200-L360】
- do zasilenia kart „Strategie wymagające uwagi” wymagane są nazwy strategii (`strategy`) oraz sygnały ryzyka (`risk_action`, `risk_flags`, `stress_overrides`), aby agregator mógł policzyć liczbę blokad/zamrożeń/override'ów i ustalić ostatnie zdarzenie dla każdej strategii.【F:ui/backend/runtime_service.py†L300-L470】【F:ui/qml/dashboard/RiskJournalPanel.qml†L360-L520】
- akcje operatora (`requestFreeze`, `requestUnfreeze`, `requestUnblock`) wykorzystują metadane wpisu – należy upewnić się, że log zawiera pola identyfikujące decyzję (np. `event`, `timestamp`, `portfolio`) na potrzeby audytu.【F:ui/backend/runtime_service.py†L300-L360】

## Priorytetowe poprawki
1. **Alerty degradacji feedu** – zdefiniować progi SLA i integrację z HyperCare, aby `feedHealth` generowało ostrzeżenia push/mail przy przekroczeniu limitów latencji lub liczby błędów.【F:ui/backend/runtime_service.py†L600-L990】
2. **Uporządkowanie API AutoTradera** – udostępnić publiczną metodę wyzwalającą pojedynczy cykl decyzyjny oraz zredukować zależności od atrybutów `_execution_context`/`_schedule_mode`, co uprości dalszą automatyzację i testowanie.【F:bot_core/auto_trader/app.py†L1-L200】
3. **Marketplace i raportowanie futures** – przygotować proces publikacji presetów wraz z podpisami oraz zautomatyzować raport `reports/exchanges/*.csv`, by utrzymać parytet futures z CryptoHopperem i dokumentować checklisty HyperCare.【F:docs/benchmark/cryptohopper_comparison.md†L35-L97】【F:scripts/list_exchange_adapters.py†L1-L150】

## Proponowane sprinty
### Sprint 3 – Obserwowalność runtime
- Zdefiniować progi SLA i kanały eskalacji dla `feedHealth`, generując alerty HyperCare i widoki statusu na podstawie metryk long-pollowych.【F:ui/backend/runtime_service.py†L600-L990】【F:ui/qml/dashboard/RuntimeOverview.qml†L640-L760】
- Dodać eksport metryk long-polla do centralnego `MetricsRegistry` (np. Prometheus/OpenMetrics) i zbudować dashboard porównujący gRPC vs fallback.【F:bot_core/observability/ui_metrics.py†L1-L200】【F:bot_core/exchanges/streaming.py†L150-L420】
- Rozszerzyć testy (`tests/integration/test_grpc_transport.py`, `tests/ui/test_runtime_overview.py`) o scenariusze degradacji feedu i brakujących metadanych, aby potwierdzić alerty.【F:tests/integration/test_grpc_transport.py†L200-L360】【F:tests/ui/test_runtime_overview.py†L1-L220】

### Sprint 4 – Marketplace i roadmapa giełdowa
- Utrzymać pipeline publikacji presetów (`scripts/build_marketplace_catalog.py`, workflow `marketplace-catalog`) i skalować katalog do ≥15 publicznych presetów wraz z recenzjami.【F:docs/benchmark/cryptohopper_comparison.md†L24-L97】【F:docs/marketplace/README.md†L1-L99】
- Dodać adaptery Deribit/BitMEX (REST + long-poll) wraz z profilami paper/live, aby zrównać liczbę giełd z konkurencją CryptoHopper.【F:docs/benchmark/cryptohopper_comparison.md†L35-L66】
- Skorelować marketing Stress Lab z roadmapą produktów – eksportować raporty stres-testów i linkować je w materiałach sprzedażowych.【F:docs/benchmark/cryptohopper_comparison.md†L15-L37】
