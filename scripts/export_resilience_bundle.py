"""Build a signed resilience bundle with Stage6 failover artefacts.

The Stage6 operational workflow requires shipping the JSON report generated by
``scripts/failover_drill.py`` together with its signature and any supplemental
files (for example operator notes or latency snapshots).  This helper assembles
the artefacts into a tarball, creates a manifest describing the contents and
signs it using the same HMAC scheme as the OEM bundle tooling.  The resulting
archive can be verified offline before distributing it to disaster recovery
stations.
"""

from __future__ import annotations

import argparse
import datetime as _dt
import hashlib
import json
import logging
import os
import shutil
import stat
import subprocess
import tarfile
import tempfile
import sys
from dataclasses import dataclass
from pathlib import Path, PurePosixPath
from typing import Iterable, List, Mapping, Optional, Sequence


REPO_ROOT = Path(__file__).resolve().parents[1]

if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))


from deploy.packaging.build_core_bundle import (  # noqa: E402
    SignatureManager,
    _ensure_no_symlinks,
    _ensure_windows_safe_component,
    _ensure_windows_safe_tree,
    _validate_bundle_version,
)


DEFAULT_REPORT = (
    REPO_ROOT
    / "var"
    / "audit"
    / "stage6"
    / "resilience"
    / "resilience_failover_report.json"
)
ARCHIVE_PREFIX = "resilience-bundle"


@dataclass(frozen=True)
class BundleAsset:
    """Artefact that will be included in the resilience bundle."""

    virtual_path: PurePosixPath
    source: Path
    kind: str


def _now_utc() -> str:
    return _dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def _ensure_output_directory(path: Path) -> Path:
    path = path.expanduser()
    if path.exists():
        if path.is_symlink():
            raise ValueError(f"Output directory must not be a symlink: {path}")
        if not path.is_dir():
            raise ValueError(f"Output directory is not a directory: {path}")
    else:
        path.mkdir(parents=True)
    return path


def _load_signing_key_from_path(path: Path) -> bytes:
    _ensure_no_symlinks(path, label="Signing key path")
    resolved = path.resolve()
    _ensure_windows_safe_tree(resolved, label="Signing key path")
    if not resolved.is_file():
        raise ValueError(f"Signing key path must reference a file: {resolved}")
    if os.name != "nt":
        mode = resolved.stat().st_mode
        if mode & (stat.S_IRWXG | stat.S_IRWXO):
            raise ValueError(
                "Signing key permissions are too permissive; expected 600-style access"
            )
    return resolved.read_bytes()


def _compute_sha256(path: Path) -> str:
    hasher = hashlib.sha256()
    with path.open("rb") as handle:
        for chunk in iter(lambda: handle.read(1024 * 1024), b""):
            hasher.update(chunk)
    return hasher.hexdigest()


def _validate_file(path: Path, *, label: str) -> Path:
    _ensure_no_symlinks(path, label=label)
    resolved = path.resolve()
    _ensure_windows_safe_tree(resolved, label=label)
    if not resolved.exists():
        raise FileNotFoundError(f"{label} not found: {resolved}")
    if resolved.is_dir():
        raise ValueError(f"{label} must be a file: {resolved}")
    _ensure_windows_safe_component(
        component=resolved.name,
        label=label,
        context=resolved.name,
    )
    return resolved


def _collect_assets(
    report_path: Path,
    signature_path: Optional[Path],
    extras: Sequence[Path],
) -> List[BundleAsset]:
    assets: List[BundleAsset] = []
    seen: dict[str, PurePosixPath] = {}

    def add_asset(source: Path, *, virtual_path: PurePosixPath, kind: str) -> None:
        key = virtual_path.as_posix().casefold()
        if key in seen:
            raise ValueError(
                f"Duplicate bundle entry detected: {virtual_path} conflicts with {seen[key]}"
            )
        seen[key] = virtual_path
        assets.append(BundleAsset(virtual_path=virtual_path, source=source, kind=kind))

    report_file = _validate_file(report_path, label="Resilience report")
    add_asset(
        report_file,
        virtual_path=PurePosixPath("reports") / report_file.name,
        kind="report",
    )

    if signature_path is not None:
        signature_file = _validate_file(signature_path, label="Resilience report signature")
        add_asset(
            signature_file,
            virtual_path=PurePosixPath("reports")
            / f"{report_file.name}.sig",
            kind="signature",
        )

    for extra in extras:
        resolved = _validate_file(extra, label="Extra artefact")
        add_asset(
            resolved,
            virtual_path=PurePosixPath("extras") / resolved.name,
            kind="extra",
        )

    return assets


def _copy_assets(assets: Iterable[BundleAsset], destination_root: Path) -> None:
    for asset in assets:
        target = destination_root / asset.virtual_path.as_posix()
        target.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(asset.source, target)


def _build_manifest(
    *,
    version: str,
    assets: Sequence[BundleAsset],
    staging_root: Path,
) -> Mapping[str, object]:
    files: List[Mapping[str, object]] = []
    for asset in assets:
        target = staging_root / asset.virtual_path.as_posix()
        files.append(
            {
                "path": asset.virtual_path.as_posix(),
                "kind": asset.kind,
                "sha256": _compute_sha256(target),
                "size_bytes": target.stat().st_size,
            }
        )

    manifest: dict[str, object] = {
        "version": version,
        "generated_at": _now_utc(),
        "files": sorted(files, key=lambda entry: entry["path"]),
    }

    for asset in assets:
        if asset.kind == "report":
            manifest["report_path"] = asset.virtual_path.as_posix()
            break

    git_revision = _git_revision()
    if git_revision:
        manifest["git_revision"] = git_revision

    return manifest


def _git_revision() -> Optional[str]:
    try:
        output = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=REPO_ROOT)
    except (FileNotFoundError, subprocess.CalledProcessError):
        return None
    return output.decode("ascii").strip()


def _tar_directory(source: Path, destination: Path) -> None:
    with tarfile.open(destination, "w:gz") as archive:
        archive.add(source, arcname=".")


def build_resilience_bundle(
    *,
    version: str,
    report: Path,
    signature: Optional[Path],
    extras: Sequence[Path],
    output_dir: Path,
    signing_key: bytes,
    digest_algorithm: str = "sha384",
    key_id: Optional[str] = None,
    logger: Optional[logging.Logger] = None,
) -> Path:
    log = logger or logging.getLogger("resilience_bundle")

    version = _validate_bundle_version(version)
    output_dir = _ensure_output_directory(output_dir)

    archive_path = output_dir / f"{ARCHIVE_PREFIX}-{version}.tar.gz"
    if archive_path.exists():
        raise FileExistsError(f"Bundle already exists: {archive_path}")

    assets = _collect_assets(report, signature, extras)

    staging_root = Path(tempfile.mkdtemp(prefix="resilience_bundle_"))
    try:
        _copy_assets(assets, staging_root)

        manifest = _build_manifest(version=version, assets=assets, staging_root=staging_root)
        manifest_path = staging_root / "manifest.json"
        manifest_path.write_text(json.dumps(manifest, indent=2, sort_keys=True) + "\n", encoding="utf-8")

        signature_manager = SignatureManager(
            signing_key,
            digest_algorithm=digest_algorithm,
            key_id=key_id,
        )
        manifest_digest = signature_manager.digest_file(manifest_path)
        signature_manager.write_signature_document(
            {"path": "manifest.json", digest_algorithm: manifest_digest},
            manifest_path.with_suffix(".sig"),
        )

        _tar_directory(staging_root, archive_path)
        log.info("Created resilience bundle: %s", archive_path)
        return archive_path
    finally:
        shutil.rmtree(staging_root, ignore_errors=True)


def _resolve_signature_path(report_path: Path, provided: Optional[Path]) -> Optional[Path]:
    if provided is not None:
        return provided
    candidate = report_path.with_suffix(report_path.suffix + ".sig")
    return candidate if candidate.exists() else None


def _parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--version", required=True, help="Bundle version identifier")
    parser.add_argument(
        "--report",
        default=DEFAULT_REPORT,
        type=Path,
        help="Path to resilience failover JSON report",
    )
    parser.add_argument(
        "--signature",
        type=Path,
        help="Path to the report signature (defaults to <report>.sig if present)",
    )
    parser.add_argument(
        "--include",
        action="append",
        default=[],
        type=Path,
        help="Additional artefact to package inside the bundle",
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        type=Path,
        help="Directory where the bundle will be stored",
    )
    parser.add_argument(
        "--signing-key-path",
        type=Path,
        help="File containing the HMAC signing key",
    )
    parser.add_argument(
        "--signing-key-env",
        help="Environment variable containing the HMAC signing key",
    )
    parser.add_argument(
        "--digest",
        default="sha384",
        help="Digest algorithm for manifest signatures (default: sha384)",
    )
    parser.add_argument("--key-id", help="Optional identifier embedded in the signature")
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
    )
    return parser.parse_args(argv)


def _resolve_signing_key(args: argparse.Namespace) -> bytes:
    if args.signing_key_path:
        return _load_signing_key_from_path(args.signing_key_path)
    if args.signing_key_env:
        value = os.environ.get(args.signing_key_env)
        if not value:
            raise ValueError(
                f"Environment variable {args.signing_key_env} is not set or empty"
            )
        return value.encode("utf-8")
    raise ValueError("Signing key must be provided via --signing-key-path or --signing-key-env")


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = _parse_args(argv)
    logging.basicConfig(level=args.log_level, format="%(asctime)s %(levelname)s %(message)s")

    try:
        signing_key = _resolve_signing_key(args)
        signature = _resolve_signature_path(args.report, args.signature)
        build_resilience_bundle(
            version=args.version,
            report=args.report,
            signature=signature,
            extras=args.include,
            output_dir=args.output_dir,
            signing_key=signing_key,
            digest_algorithm=args.digest,
            key_id=args.key_id,
        )
    except Exception as exc:  # pragma: no cover - handled in tests via CLI
        logging.getLogger("resilience_bundle").error("Failed to build resilience bundle: %s", exc)
        return 2
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())

