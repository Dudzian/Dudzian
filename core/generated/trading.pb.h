// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trading.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_trading_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_trading_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_trading_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_trading_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_trading_2eproto;
namespace botcore {
namespace trading {
namespace v1 {
class ActivateMarketplacePresetRequest;
struct ActivateMarketplacePresetRequestDefaultTypeInternal;
extern ActivateMarketplacePresetRequestDefaultTypeInternal _ActivateMarketplacePresetRequest_default_instance_;
class ActivateMarketplacePresetResponse;
struct ActivateMarketplacePresetResponseDefaultTypeInternal;
extern ActivateMarketplacePresetResponseDefaultTypeInternal _ActivateMarketplacePresetResponse_default_instance_;
class CancelOrderRequest;
struct CancelOrderRequestDefaultTypeInternal;
extern CancelOrderRequestDefaultTypeInternal _CancelOrderRequest_default_instance_;
class CancelOrderResponse;
struct CancelOrderResponseDefaultTypeInternal;
extern CancelOrderResponseDefaultTypeInternal _CancelOrderResponse_default_instance_;
class CandleGranularity;
struct CandleGranularityDefaultTypeInternal;
extern CandleGranularityDefaultTypeInternal _CandleGranularity_default_instance_;
class ExportMarketplacePresetRequest;
struct ExportMarketplacePresetRequestDefaultTypeInternal;
extern ExportMarketplacePresetRequestDefaultTypeInternal _ExportMarketplacePresetRequest_default_instance_;
class ExportMarketplacePresetResponse;
struct ExportMarketplacePresetResponseDefaultTypeInternal;
extern ExportMarketplacePresetResponseDefaultTypeInternal _ExportMarketplacePresetResponse_default_instance_;
class ExposureLimit;
struct ExposureLimitDefaultTypeInternal;
extern ExposureLimitDefaultTypeInternal _ExposureLimit_default_instance_;
class GetOhlcvHistoryRequest;
struct GetOhlcvHistoryRequestDefaultTypeInternal;
extern GetOhlcvHistoryRequestDefaultTypeInternal _GetOhlcvHistoryRequest_default_instance_;
class GetOhlcvHistoryResponse;
struct GetOhlcvHistoryResponseDefaultTypeInternal;
extern GetOhlcvHistoryResponseDefaultTypeInternal _GetOhlcvHistoryResponse_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class ImportMarketplacePresetRequest;
struct ImportMarketplacePresetRequestDefaultTypeInternal;
extern ImportMarketplacePresetRequestDefaultTypeInternal _ImportMarketplacePresetRequest_default_instance_;
class ImportMarketplacePresetResponse;
struct ImportMarketplacePresetResponseDefaultTypeInternal;
extern ImportMarketplacePresetResponseDefaultTypeInternal _ImportMarketplacePresetResponse_default_instance_;
class Instrument;
struct InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class ListMarketplacePresetsRequest;
struct ListMarketplacePresetsRequestDefaultTypeInternal;
extern ListMarketplacePresetsRequestDefaultTypeInternal _ListMarketplacePresetsRequest_default_instance_;
class ListMarketplacePresetsResponse;
struct ListMarketplacePresetsResponseDefaultTypeInternal;
extern ListMarketplacePresetsResponseDefaultTypeInternal _ListMarketplacePresetsResponse_default_instance_;
class ListTradableInstrumentsRequest;
struct ListTradableInstrumentsRequestDefaultTypeInternal;
extern ListTradableInstrumentsRequestDefaultTypeInternal _ListTradableInstrumentsRequest_default_instance_;
class ListTradableInstrumentsResponse;
struct ListTradableInstrumentsResponseDefaultTypeInternal;
extern ListTradableInstrumentsResponseDefaultTypeInternal _ListTradableInstrumentsResponse_default_instance_;
class MarketplacePresetSummary;
struct MarketplacePresetSummaryDefaultTypeInternal;
extern MarketplacePresetSummaryDefaultTypeInternal _MarketplacePresetSummary_default_instance_;
class MetricsAck;
struct MetricsAckDefaultTypeInternal;
extern MetricsAckDefaultTypeInternal _MetricsAck_default_instance_;
class MetricsRequest;
struct MetricsRequestDefaultTypeInternal;
extern MetricsRequestDefaultTypeInternal _MetricsRequest_default_instance_;
class MetricsSnapshot;
struct MetricsSnapshotDefaultTypeInternal;
extern MetricsSnapshotDefaultTypeInternal _MetricsSnapshot_default_instance_;
class OhlcvCandle;
struct OhlcvCandleDefaultTypeInternal;
extern OhlcvCandleDefaultTypeInternal _OhlcvCandle_default_instance_;
class OrderConstraintViolation;
struct OrderConstraintViolationDefaultTypeInternal;
extern OrderConstraintViolationDefaultTypeInternal _OrderConstraintViolation_default_instance_;
class RemoveMarketplacePresetRequest;
struct RemoveMarketplacePresetRequestDefaultTypeInternal;
extern RemoveMarketplacePresetRequestDefaultTypeInternal _RemoveMarketplacePresetRequest_default_instance_;
class RemoveMarketplacePresetResponse;
struct RemoveMarketplacePresetResponseDefaultTypeInternal;
extern RemoveMarketplacePresetResponseDefaultTypeInternal _RemoveMarketplacePresetResponse_default_instance_;
class RiskState;
struct RiskStateDefaultTypeInternal;
extern RiskStateDefaultTypeInternal _RiskState_default_instance_;
class RiskStateRequest;
struct RiskStateRequestDefaultTypeInternal;
extern RiskStateRequestDefaultTypeInternal _RiskStateRequest_default_instance_;
class StreamOhlcvIncrement;
struct StreamOhlcvIncrementDefaultTypeInternal;
extern StreamOhlcvIncrementDefaultTypeInternal _StreamOhlcvIncrement_default_instance_;
class StreamOhlcvRequest;
struct StreamOhlcvRequestDefaultTypeInternal;
extern StreamOhlcvRequestDefaultTypeInternal _StreamOhlcvRequest_default_instance_;
class StreamOhlcvSnapshot;
struct StreamOhlcvSnapshotDefaultTypeInternal;
extern StreamOhlcvSnapshotDefaultTypeInternal _StreamOhlcvSnapshot_default_instance_;
class StreamOhlcvUpdate;
struct StreamOhlcvUpdateDefaultTypeInternal;
extern StreamOhlcvUpdateDefaultTypeInternal _StreamOhlcvUpdate_default_instance_;
class SubmitOrderRequest;
struct SubmitOrderRequestDefaultTypeInternal;
extern SubmitOrderRequestDefaultTypeInternal _SubmitOrderRequest_default_instance_;
class SubmitOrderResponse;
struct SubmitOrderResponseDefaultTypeInternal;
extern SubmitOrderResponseDefaultTypeInternal _SubmitOrderResponse_default_instance_;
class TradableInstrumentMetadata;
struct TradableInstrumentMetadataDefaultTypeInternal;
extern TradableInstrumentMetadataDefaultTypeInternal _TradableInstrumentMetadata_default_instance_;
}  // namespace v1
}  // namespace trading
}  // namespace botcore
PROTOBUF_NAMESPACE_OPEN
template<> ::botcore::trading::v1::ActivateMarketplacePresetRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::ActivateMarketplacePresetRequest>(Arena*);
template<> ::botcore::trading::v1::ActivateMarketplacePresetResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::ActivateMarketplacePresetResponse>(Arena*);
template<> ::botcore::trading::v1::CancelOrderRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::CancelOrderRequest>(Arena*);
template<> ::botcore::trading::v1::CancelOrderResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::CancelOrderResponse>(Arena*);
template<> ::botcore::trading::v1::CandleGranularity* Arena::CreateMaybeMessage<::botcore::trading::v1::CandleGranularity>(Arena*);
template<> ::botcore::trading::v1::ExportMarketplacePresetRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::ExportMarketplacePresetRequest>(Arena*);
template<> ::botcore::trading::v1::ExportMarketplacePresetResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::ExportMarketplacePresetResponse>(Arena*);
template<> ::botcore::trading::v1::ExposureLimit* Arena::CreateMaybeMessage<::botcore::trading::v1::ExposureLimit>(Arena*);
template<> ::botcore::trading::v1::GetOhlcvHistoryRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::GetOhlcvHistoryRequest>(Arena*);
template<> ::botcore::trading::v1::GetOhlcvHistoryResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::GetOhlcvHistoryResponse>(Arena*);
template<> ::botcore::trading::v1::HealthCheckRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::HealthCheckRequest>(Arena*);
template<> ::botcore::trading::v1::HealthCheckResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::HealthCheckResponse>(Arena*);
template<> ::botcore::trading::v1::ImportMarketplacePresetRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::ImportMarketplacePresetRequest>(Arena*);
template<> ::botcore::trading::v1::ImportMarketplacePresetResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::ImportMarketplacePresetResponse>(Arena*);
template<> ::botcore::trading::v1::Instrument* Arena::CreateMaybeMessage<::botcore::trading::v1::Instrument>(Arena*);
template<> ::botcore::trading::v1::ListMarketplacePresetsRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::ListMarketplacePresetsRequest>(Arena*);
template<> ::botcore::trading::v1::ListMarketplacePresetsResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::ListMarketplacePresetsResponse>(Arena*);
template<> ::botcore::trading::v1::ListTradableInstrumentsRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::ListTradableInstrumentsRequest>(Arena*);
template<> ::botcore::trading::v1::ListTradableInstrumentsResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::ListTradableInstrumentsResponse>(Arena*);
template<> ::botcore::trading::v1::MarketplacePresetSummary* Arena::CreateMaybeMessage<::botcore::trading::v1::MarketplacePresetSummary>(Arena*);
template<> ::botcore::trading::v1::MetricsAck* Arena::CreateMaybeMessage<::botcore::trading::v1::MetricsAck>(Arena*);
template<> ::botcore::trading::v1::MetricsRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::MetricsRequest>(Arena*);
template<> ::botcore::trading::v1::MetricsSnapshot* Arena::CreateMaybeMessage<::botcore::trading::v1::MetricsSnapshot>(Arena*);
template<> ::botcore::trading::v1::OhlcvCandle* Arena::CreateMaybeMessage<::botcore::trading::v1::OhlcvCandle>(Arena*);
template<> ::botcore::trading::v1::OrderConstraintViolation* Arena::CreateMaybeMessage<::botcore::trading::v1::OrderConstraintViolation>(Arena*);
template<> ::botcore::trading::v1::RemoveMarketplacePresetRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::RemoveMarketplacePresetRequest>(Arena*);
template<> ::botcore::trading::v1::RemoveMarketplacePresetResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::RemoveMarketplacePresetResponse>(Arena*);
template<> ::botcore::trading::v1::RiskState* Arena::CreateMaybeMessage<::botcore::trading::v1::RiskState>(Arena*);
template<> ::botcore::trading::v1::RiskStateRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::RiskStateRequest>(Arena*);
template<> ::botcore::trading::v1::StreamOhlcvIncrement* Arena::CreateMaybeMessage<::botcore::trading::v1::StreamOhlcvIncrement>(Arena*);
template<> ::botcore::trading::v1::StreamOhlcvRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::StreamOhlcvRequest>(Arena*);
template<> ::botcore::trading::v1::StreamOhlcvSnapshot* Arena::CreateMaybeMessage<::botcore::trading::v1::StreamOhlcvSnapshot>(Arena*);
template<> ::botcore::trading::v1::StreamOhlcvUpdate* Arena::CreateMaybeMessage<::botcore::trading::v1::StreamOhlcvUpdate>(Arena*);
template<> ::botcore::trading::v1::SubmitOrderRequest* Arena::CreateMaybeMessage<::botcore::trading::v1::SubmitOrderRequest>(Arena*);
template<> ::botcore::trading::v1::SubmitOrderResponse* Arena::CreateMaybeMessage<::botcore::trading::v1::SubmitOrderResponse>(Arena*);
template<> ::botcore::trading::v1::TradableInstrumentMetadata* Arena::CreateMaybeMessage<::botcore::trading::v1::TradableInstrumentMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace botcore {
namespace trading {
namespace v1 {

enum OrderSide : int {
  ORDER_SIDE_UNSPECIFIED = 0,
  ORDER_SIDE_BUY = 1,
  ORDER_SIDE_SELL = 2,
  OrderSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderSide_IsValid(int value);
constexpr OrderSide OrderSide_MIN = ORDER_SIDE_UNSPECIFIED;
constexpr OrderSide OrderSide_MAX = ORDER_SIDE_SELL;
constexpr int OrderSide_ARRAYSIZE = OrderSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderSide_descriptor();
template<typename T>
inline const std::string& OrderSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderSide_descriptor(), enum_t_value);
}
inline bool OrderSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderSide>(
    OrderSide_descriptor(), name, value);
}
enum OrderType : int {
  ORDER_TYPE_UNSPECIFIED = 0,
  ORDER_TYPE_MARKET = 1,
  ORDER_TYPE_LIMIT = 2,
  ORDER_TYPE_STOP_MARKET = 3,
  ORDER_TYPE_STOP_LIMIT = 4,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = ORDER_TYPE_UNSPECIFIED;
constexpr OrderType OrderType_MAX = ORDER_TYPE_STOP_LIMIT;
constexpr int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor();
template<typename T>
inline const std::string& OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderType_descriptor(), enum_t_value);
}
inline bool OrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum TimeInForce : int {
  TIME_IN_FORCE_UNSPECIFIED = 0,
  TIME_IN_FORCE_GTC = 1,
  TIME_IN_FORCE_GTD = 2,
  TIME_IN_FORCE_IOC = 3,
  TIME_IN_FORCE_FOK = 4,
  TimeInForce_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimeInForce_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimeInForce_IsValid(int value);
constexpr TimeInForce TimeInForce_MIN = TIME_IN_FORCE_UNSPECIFIED;
constexpr TimeInForce TimeInForce_MAX = TIME_IN_FORCE_FOK;
constexpr int TimeInForce_ARRAYSIZE = TimeInForce_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeInForce_descriptor();
template<typename T>
inline const std::string& TimeInForce_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeInForce>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeInForce_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeInForce_descriptor(), enum_t_value);
}
inline bool TimeInForce_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeInForce* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeInForce>(
    TimeInForce_descriptor(), name, value);
}
enum RiskProfile : int {
  RISK_PROFILE_UNSPECIFIED = 0,
  RISK_PROFILE_CONSERVATIVE = 1,
  RISK_PROFILE_BALANCED = 2,
  RISK_PROFILE_AGGRESSIVE = 3,
  RISK_PROFILE_MANUAL = 4,
  RiskProfile_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RiskProfile_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RiskProfile_IsValid(int value);
constexpr RiskProfile RiskProfile_MIN = RISK_PROFILE_UNSPECIFIED;
constexpr RiskProfile RiskProfile_MAX = RISK_PROFILE_MANUAL;
constexpr int RiskProfile_ARRAYSIZE = RiskProfile_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RiskProfile_descriptor();
template<typename T>
inline const std::string& RiskProfile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RiskProfile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RiskProfile_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RiskProfile_descriptor(), enum_t_value);
}
inline bool RiskProfile_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RiskProfile* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RiskProfile>(
    RiskProfile_descriptor(), name, value);
}
enum OrderStatus : int {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_ACCEPTED = 1,
  ORDER_STATUS_REJECTED = 2,
  ORDER_STATUS_PENDING = 3,
  OrderStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderStatus_IsValid(int value);
constexpr OrderStatus OrderStatus_MIN = ORDER_STATUS_UNSPECIFIED;
constexpr OrderStatus OrderStatus_MAX = ORDER_STATUS_PENDING;
constexpr int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderStatus_descriptor();
template<typename T>
inline const std::string& OrderStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderStatus_descriptor(), enum_t_value);
}
inline bool OrderStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
// ===================================================================

class Instrument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.Instrument) */ {
 public:
  inline Instrument() : Instrument(nullptr) {}
  ~Instrument() override;
  explicit PROTOBUF_CONSTEXPR Instrument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instrument(const Instrument& from);
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instrument& operator=(Instrument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instrument& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }
  inline void Swap(Instrument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instrument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instrument& from) {
    Instrument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.Instrument";
  }
  protected:
  explicit Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangeFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kVenueSymbolFieldNumber = 3,
    kQuoteCurrencyFieldNumber = 4,
    kBaseCurrencyFieldNumber = 5,
  };
  // string exchange = 1;
  void clear_exchange();
  const std::string& exchange() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange();
  PROTOBUF_NODISCARD std::string* release_exchange();
  void set_allocated_exchange(std::string* exchange);
  private:
  const std::string& _internal_exchange() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const std::string& value);
  std::string* _internal_mutable_exchange();
  public:

  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string venue_symbol = 3;
  void clear_venue_symbol();
  const std::string& venue_symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_venue_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_venue_symbol();
  PROTOBUF_NODISCARD std::string* release_venue_symbol();
  void set_allocated_venue_symbol(std::string* venue_symbol);
  private:
  const std::string& _internal_venue_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_venue_symbol(const std::string& value);
  std::string* _internal_mutable_venue_symbol();
  public:

  // string quote_currency = 4;
  void clear_quote_currency();
  const std::string& quote_currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quote_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quote_currency();
  PROTOBUF_NODISCARD std::string* release_quote_currency();
  void set_allocated_quote_currency(std::string* quote_currency);
  private:
  const std::string& _internal_quote_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_currency(const std::string& value);
  std::string* _internal_mutable_quote_currency();
  public:

  // string base_currency = 5;
  void clear_base_currency();
  const std::string& base_currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_currency();
  PROTOBUF_NODISCARD std::string* release_base_currency();
  void set_allocated_base_currency(std::string* base_currency);
  private:
  const std::string& _internal_base_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_currency(const std::string& value);
  std::string* _internal_mutable_base_currency();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.Instrument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr venue_symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_currency_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_currency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class CandleGranularity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.CandleGranularity) */ {
 public:
  inline CandleGranularity() : CandleGranularity(nullptr) {}
  ~CandleGranularity() override;
  explicit PROTOBUF_CONSTEXPR CandleGranularity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CandleGranularity(const CandleGranularity& from);
  CandleGranularity(CandleGranularity&& from) noexcept
    : CandleGranularity() {
    *this = ::std::move(from);
  }

  inline CandleGranularity& operator=(const CandleGranularity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandleGranularity& operator=(CandleGranularity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandleGranularity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CandleGranularity* internal_default_instance() {
    return reinterpret_cast<const CandleGranularity*>(
               &_CandleGranularity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CandleGranularity& a, CandleGranularity& b) {
    a.Swap(&b);
  }
  inline void Swap(CandleGranularity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandleGranularity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandleGranularity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CandleGranularity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CandleGranularity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CandleGranularity& from) {
    CandleGranularity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandleGranularity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.CandleGranularity";
  }
  protected:
  explicit CandleGranularity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIso8601DurationFieldNumber = 1,
  };
  // string iso8601_duration = 1;
  void clear_iso8601_duration();
  const std::string& iso8601_duration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iso8601_duration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iso8601_duration();
  PROTOBUF_NODISCARD std::string* release_iso8601_duration();
  void set_allocated_iso8601_duration(std::string* iso8601_duration);
  private:
  const std::string& _internal_iso8601_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iso8601_duration(const std::string& value);
  std::string* _internal_mutable_iso8601_duration();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.CandleGranularity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iso8601_duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class OhlcvCandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.OhlcvCandle) */ {
 public:
  inline OhlcvCandle() : OhlcvCandle(nullptr) {}
  ~OhlcvCandle() override;
  explicit PROTOBUF_CONSTEXPR OhlcvCandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OhlcvCandle(const OhlcvCandle& from);
  OhlcvCandle(OhlcvCandle&& from) noexcept
    : OhlcvCandle() {
    *this = ::std::move(from);
  }

  inline OhlcvCandle& operator=(const OhlcvCandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline OhlcvCandle& operator=(OhlcvCandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OhlcvCandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const OhlcvCandle* internal_default_instance() {
    return reinterpret_cast<const OhlcvCandle*>(
               &_OhlcvCandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OhlcvCandle& a, OhlcvCandle& b) {
    a.Swap(&b);
  }
  inline void Swap(OhlcvCandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OhlcvCandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OhlcvCandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OhlcvCandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OhlcvCandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OhlcvCandle& from) {
    OhlcvCandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OhlcvCandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.OhlcvCandle";
  }
  protected:
  explicit OhlcvCandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kOpenTimeFieldNumber = 2,
    kGranularityFieldNumber = 9,
    kOpenFieldNumber = 3,
    kHighFieldNumber = 4,
    kLowFieldNumber = 5,
    kCloseFieldNumber = 6,
    kVolumeFieldNumber = 7,
    kSequenceFieldNumber = 10,
    kClosedFieldNumber = 8,
  };
  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // .google.protobuf.Timestamp open_time = 2;
  bool has_open_time() const;
  private:
  bool _internal_has_open_time() const;
  public:
  void clear_open_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& open_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_open_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_open_time();
  void set_allocated_open_time(::PROTOBUF_NAMESPACE_ID::Timestamp* open_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_open_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_open_time();
  public:
  void unsafe_arena_set_allocated_open_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* open_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_open_time();

  // .botcore.trading.v1.CandleGranularity granularity = 9;
  bool has_granularity() const;
  private:
  bool _internal_has_granularity() const;
  public:
  void clear_granularity();
  const ::botcore::trading::v1::CandleGranularity& granularity() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::CandleGranularity* release_granularity();
  ::botcore::trading::v1::CandleGranularity* mutable_granularity();
  void set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity);
  private:
  const ::botcore::trading::v1::CandleGranularity& _internal_granularity() const;
  ::botcore::trading::v1::CandleGranularity* _internal_mutable_granularity();
  public:
  void unsafe_arena_set_allocated_granularity(
      ::botcore::trading::v1::CandleGranularity* granularity);
  ::botcore::trading::v1::CandleGranularity* unsafe_arena_release_granularity();

  // double open = 3;
  void clear_open();
  double open() const;
  void set_open(double value);
  private:
  double _internal_open() const;
  void _internal_set_open(double value);
  public:

  // double high = 4;
  void clear_high();
  double high() const;
  void set_high(double value);
  private:
  double _internal_high() const;
  void _internal_set_high(double value);
  public:

  // double low = 5;
  void clear_low();
  double low() const;
  void set_low(double value);
  private:
  double _internal_low() const;
  void _internal_set_low(double value);
  public:

  // double close = 6;
  void clear_close();
  double close() const;
  void set_close(double value);
  private:
  double _internal_close() const;
  void _internal_set_close(double value);
  public:

  // double volume = 7;
  void clear_volume();
  double volume() const;
  void set_volume(double value);
  private:
  double _internal_volume() const;
  void _internal_set_volume(double value);
  public:

  // uint64 sequence = 10;
  void clear_sequence();
  uint64_t sequence() const;
  void set_sequence(uint64_t value);
  private:
  uint64_t _internal_sequence() const;
  void _internal_set_sequence(uint64_t value);
  public:

  // bool closed = 8;
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.OhlcvCandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::Instrument* instrument_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* open_time_;
    ::botcore::trading::v1::CandleGranularity* granularity_;
    double open_;
    double high_;
    double low_;
    double close_;
    double volume_;
    uint64_t sequence_;
    bool closed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class GetOhlcvHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.GetOhlcvHistoryRequest) */ {
 public:
  inline GetOhlcvHistoryRequest() : GetOhlcvHistoryRequest(nullptr) {}
  ~GetOhlcvHistoryRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOhlcvHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOhlcvHistoryRequest(const GetOhlcvHistoryRequest& from);
  GetOhlcvHistoryRequest(GetOhlcvHistoryRequest&& from) noexcept
    : GetOhlcvHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetOhlcvHistoryRequest& operator=(const GetOhlcvHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOhlcvHistoryRequest& operator=(GetOhlcvHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOhlcvHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOhlcvHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetOhlcvHistoryRequest*>(
               &_GetOhlcvHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetOhlcvHistoryRequest& a, GetOhlcvHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOhlcvHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOhlcvHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOhlcvHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOhlcvHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOhlcvHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOhlcvHistoryRequest& from) {
    GetOhlcvHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOhlcvHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.GetOhlcvHistoryRequest";
  }
  protected:
  explicit GetOhlcvHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kGranularityFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kLimitFieldNumber = 5,
  };
  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // .botcore.trading.v1.CandleGranularity granularity = 2;
  bool has_granularity() const;
  private:
  bool _internal_has_granularity() const;
  public:
  void clear_granularity();
  const ::botcore::trading::v1::CandleGranularity& granularity() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::CandleGranularity* release_granularity();
  ::botcore::trading::v1::CandleGranularity* mutable_granularity();
  void set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity);
  private:
  const ::botcore::trading::v1::CandleGranularity& _internal_granularity() const;
  ::botcore::trading::v1::CandleGranularity* _internal_mutable_granularity();
  public:
  void unsafe_arena_set_allocated_granularity(
      ::botcore::trading::v1::CandleGranularity* granularity);
  ::botcore::trading::v1::CandleGranularity* unsafe_arena_release_granularity();

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // uint32 limit = 5;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.GetOhlcvHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::Instrument* instrument_;
    ::botcore::trading::v1::CandleGranularity* granularity_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    uint32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class GetOhlcvHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.GetOhlcvHistoryResponse) */ {
 public:
  inline GetOhlcvHistoryResponse() : GetOhlcvHistoryResponse(nullptr) {}
  ~GetOhlcvHistoryResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOhlcvHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOhlcvHistoryResponse(const GetOhlcvHistoryResponse& from);
  GetOhlcvHistoryResponse(GetOhlcvHistoryResponse&& from) noexcept
    : GetOhlcvHistoryResponse() {
    *this = ::std::move(from);
  }

  inline GetOhlcvHistoryResponse& operator=(const GetOhlcvHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOhlcvHistoryResponse& operator=(GetOhlcvHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOhlcvHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOhlcvHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetOhlcvHistoryResponse*>(
               &_GetOhlcvHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetOhlcvHistoryResponse& a, GetOhlcvHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOhlcvHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOhlcvHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOhlcvHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOhlcvHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOhlcvHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOhlcvHistoryResponse& from) {
    GetOhlcvHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOhlcvHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.GetOhlcvHistoryResponse";
  }
  protected:
  explicit GetOhlcvHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandlesFieldNumber = 1,
    kNextStartTimeFieldNumber = 3,
    kHasMoreFieldNumber = 2,
  };
  // repeated .botcore.trading.v1.OhlcvCandle candles = 1;
  int candles_size() const;
  private:
  int _internal_candles_size() const;
  public:
  void clear_candles();
  ::botcore::trading::v1::OhlcvCandle* mutable_candles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >*
      mutable_candles();
  private:
  const ::botcore::trading::v1::OhlcvCandle& _internal_candles(int index) const;
  ::botcore::trading::v1::OhlcvCandle* _internal_add_candles();
  public:
  const ::botcore::trading::v1::OhlcvCandle& candles(int index) const;
  ::botcore::trading::v1::OhlcvCandle* add_candles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >&
      candles() const;

  // .google.protobuf.Timestamp next_start_time = 3;
  bool has_next_start_time() const;
  private:
  bool _internal_has_next_start_time() const;
  public:
  void clear_next_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_start_time();
  void set_allocated_next_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* next_start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_start_time();
  public:
  void unsafe_arena_set_allocated_next_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_start_time();

  // bool has_more = 2;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.GetOhlcvHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle > candles_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_start_time_;
    bool has_more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class StreamOhlcvRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.StreamOhlcvRequest) */ {
 public:
  inline StreamOhlcvRequest() : StreamOhlcvRequest(nullptr) {}
  ~StreamOhlcvRequest() override;
  explicit PROTOBUF_CONSTEXPR StreamOhlcvRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOhlcvRequest(const StreamOhlcvRequest& from);
  StreamOhlcvRequest(StreamOhlcvRequest&& from) noexcept
    : StreamOhlcvRequest() {
    *this = ::std::move(from);
  }

  inline StreamOhlcvRequest& operator=(const StreamOhlcvRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOhlcvRequest& operator=(StreamOhlcvRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOhlcvRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOhlcvRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOhlcvRequest*>(
               &_StreamOhlcvRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamOhlcvRequest& a, StreamOhlcvRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOhlcvRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOhlcvRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOhlcvRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOhlcvRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOhlcvRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOhlcvRequest& from) {
    StreamOhlcvRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOhlcvRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.StreamOhlcvRequest";
  }
  protected:
  explicit StreamOhlcvRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kGranularityFieldNumber = 2,
    kDeliverSnapshotsFieldNumber = 3,
  };
  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // .botcore.trading.v1.CandleGranularity granularity = 2;
  bool has_granularity() const;
  private:
  bool _internal_has_granularity() const;
  public:
  void clear_granularity();
  const ::botcore::trading::v1::CandleGranularity& granularity() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::CandleGranularity* release_granularity();
  ::botcore::trading::v1::CandleGranularity* mutable_granularity();
  void set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity);
  private:
  const ::botcore::trading::v1::CandleGranularity& _internal_granularity() const;
  ::botcore::trading::v1::CandleGranularity* _internal_mutable_granularity();
  public:
  void unsafe_arena_set_allocated_granularity(
      ::botcore::trading::v1::CandleGranularity* granularity);
  ::botcore::trading::v1::CandleGranularity* unsafe_arena_release_granularity();

  // bool deliver_snapshots = 3;
  void clear_deliver_snapshots();
  bool deliver_snapshots() const;
  void set_deliver_snapshots(bool value);
  private:
  bool _internal_deliver_snapshots() const;
  void _internal_set_deliver_snapshots(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.StreamOhlcvRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::Instrument* instrument_;
    ::botcore::trading::v1::CandleGranularity* granularity_;
    bool deliver_snapshots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class StreamOhlcvUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.StreamOhlcvUpdate) */ {
 public:
  inline StreamOhlcvUpdate() : StreamOhlcvUpdate(nullptr) {}
  ~StreamOhlcvUpdate() override;
  explicit PROTOBUF_CONSTEXPR StreamOhlcvUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOhlcvUpdate(const StreamOhlcvUpdate& from);
  StreamOhlcvUpdate(StreamOhlcvUpdate&& from) noexcept
    : StreamOhlcvUpdate() {
    *this = ::std::move(from);
  }

  inline StreamOhlcvUpdate& operator=(const StreamOhlcvUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOhlcvUpdate& operator=(StreamOhlcvUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOhlcvUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSnapshot = 1,
    kIncrement = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const StreamOhlcvUpdate* internal_default_instance() {
    return reinterpret_cast<const StreamOhlcvUpdate*>(
               &_StreamOhlcvUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamOhlcvUpdate& a, StreamOhlcvUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOhlcvUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOhlcvUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOhlcvUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOhlcvUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOhlcvUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOhlcvUpdate& from) {
    StreamOhlcvUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOhlcvUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.StreamOhlcvUpdate";
  }
  protected:
  explicit StreamOhlcvUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kIncrementFieldNumber = 2,
  };
  // .botcore.trading.v1.StreamOhlcvSnapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::botcore::trading::v1::StreamOhlcvSnapshot& snapshot() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::StreamOhlcvSnapshot* release_snapshot();
  ::botcore::trading::v1::StreamOhlcvSnapshot* mutable_snapshot();
  void set_allocated_snapshot(::botcore::trading::v1::StreamOhlcvSnapshot* snapshot);
  private:
  const ::botcore::trading::v1::StreamOhlcvSnapshot& _internal_snapshot() const;
  ::botcore::trading::v1::StreamOhlcvSnapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::botcore::trading::v1::StreamOhlcvSnapshot* snapshot);
  ::botcore::trading::v1::StreamOhlcvSnapshot* unsafe_arena_release_snapshot();

  // .botcore.trading.v1.StreamOhlcvIncrement increment = 2;
  bool has_increment() const;
  private:
  bool _internal_has_increment() const;
  public:
  void clear_increment();
  const ::botcore::trading::v1::StreamOhlcvIncrement& increment() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::StreamOhlcvIncrement* release_increment();
  ::botcore::trading::v1::StreamOhlcvIncrement* mutable_increment();
  void set_allocated_increment(::botcore::trading::v1::StreamOhlcvIncrement* increment);
  private:
  const ::botcore::trading::v1::StreamOhlcvIncrement& _internal_increment() const;
  ::botcore::trading::v1::StreamOhlcvIncrement* _internal_mutable_increment();
  public:
  void unsafe_arena_set_allocated_increment(
      ::botcore::trading::v1::StreamOhlcvIncrement* increment);
  ::botcore::trading::v1::StreamOhlcvIncrement* unsafe_arena_release_increment();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:botcore.trading.v1.StreamOhlcvUpdate)
 private:
  class _Internal;
  void set_has_snapshot();
  void set_has_increment();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::botcore::trading::v1::StreamOhlcvSnapshot* snapshot_;
      ::botcore::trading::v1::StreamOhlcvIncrement* increment_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class StreamOhlcvSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.StreamOhlcvSnapshot) */ {
 public:
  inline StreamOhlcvSnapshot() : StreamOhlcvSnapshot(nullptr) {}
  ~StreamOhlcvSnapshot() override;
  explicit PROTOBUF_CONSTEXPR StreamOhlcvSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOhlcvSnapshot(const StreamOhlcvSnapshot& from);
  StreamOhlcvSnapshot(StreamOhlcvSnapshot&& from) noexcept
    : StreamOhlcvSnapshot() {
    *this = ::std::move(from);
  }

  inline StreamOhlcvSnapshot& operator=(const StreamOhlcvSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOhlcvSnapshot& operator=(StreamOhlcvSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOhlcvSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOhlcvSnapshot* internal_default_instance() {
    return reinterpret_cast<const StreamOhlcvSnapshot*>(
               &_StreamOhlcvSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamOhlcvSnapshot& a, StreamOhlcvSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOhlcvSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOhlcvSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOhlcvSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOhlcvSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOhlcvSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOhlcvSnapshot& from) {
    StreamOhlcvSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOhlcvSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.StreamOhlcvSnapshot";
  }
  protected:
  explicit StreamOhlcvSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandlesFieldNumber = 1,
  };
  // repeated .botcore.trading.v1.OhlcvCandle candles = 1;
  int candles_size() const;
  private:
  int _internal_candles_size() const;
  public:
  void clear_candles();
  ::botcore::trading::v1::OhlcvCandle* mutable_candles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >*
      mutable_candles();
  private:
  const ::botcore::trading::v1::OhlcvCandle& _internal_candles(int index) const;
  ::botcore::trading::v1::OhlcvCandle* _internal_add_candles();
  public:
  const ::botcore::trading::v1::OhlcvCandle& candles(int index) const;
  ::botcore::trading::v1::OhlcvCandle* add_candles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >&
      candles() const;

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.StreamOhlcvSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle > candles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class StreamOhlcvIncrement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.StreamOhlcvIncrement) */ {
 public:
  inline StreamOhlcvIncrement() : StreamOhlcvIncrement(nullptr) {}
  ~StreamOhlcvIncrement() override;
  explicit PROTOBUF_CONSTEXPR StreamOhlcvIncrement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOhlcvIncrement(const StreamOhlcvIncrement& from);
  StreamOhlcvIncrement(StreamOhlcvIncrement&& from) noexcept
    : StreamOhlcvIncrement() {
    *this = ::std::move(from);
  }

  inline StreamOhlcvIncrement& operator=(const StreamOhlcvIncrement& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOhlcvIncrement& operator=(StreamOhlcvIncrement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOhlcvIncrement& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOhlcvIncrement* internal_default_instance() {
    return reinterpret_cast<const StreamOhlcvIncrement*>(
               &_StreamOhlcvIncrement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamOhlcvIncrement& a, StreamOhlcvIncrement& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOhlcvIncrement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOhlcvIncrement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOhlcvIncrement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOhlcvIncrement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOhlcvIncrement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOhlcvIncrement& from) {
    StreamOhlcvIncrement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOhlcvIncrement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.StreamOhlcvIncrement";
  }
  protected:
  explicit StreamOhlcvIncrement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandleFieldNumber = 1,
  };
  // .botcore.trading.v1.OhlcvCandle candle = 1;
  bool has_candle() const;
  private:
  bool _internal_has_candle() const;
  public:
  void clear_candle();
  const ::botcore::trading::v1::OhlcvCandle& candle() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::OhlcvCandle* release_candle();
  ::botcore::trading::v1::OhlcvCandle* mutable_candle();
  void set_allocated_candle(::botcore::trading::v1::OhlcvCandle* candle);
  private:
  const ::botcore::trading::v1::OhlcvCandle& _internal_candle() const;
  ::botcore::trading::v1::OhlcvCandle* _internal_mutable_candle();
  public:
  void unsafe_arena_set_allocated_candle(
      ::botcore::trading::v1::OhlcvCandle* candle);
  ::botcore::trading::v1::OhlcvCandle* unsafe_arena_release_candle();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.StreamOhlcvIncrement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::OhlcvCandle* candle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ListTradableInstrumentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ListTradableInstrumentsRequest) */ {
 public:
  inline ListTradableInstrumentsRequest() : ListTradableInstrumentsRequest(nullptr) {}
  ~ListTradableInstrumentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListTradableInstrumentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTradableInstrumentsRequest(const ListTradableInstrumentsRequest& from);
  ListTradableInstrumentsRequest(ListTradableInstrumentsRequest&& from) noexcept
    : ListTradableInstrumentsRequest() {
    *this = ::std::move(from);
  }

  inline ListTradableInstrumentsRequest& operator=(const ListTradableInstrumentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTradableInstrumentsRequest& operator=(ListTradableInstrumentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTradableInstrumentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTradableInstrumentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTradableInstrumentsRequest*>(
               &_ListTradableInstrumentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListTradableInstrumentsRequest& a, ListTradableInstrumentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTradableInstrumentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTradableInstrumentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTradableInstrumentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTradableInstrumentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTradableInstrumentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTradableInstrumentsRequest& from) {
    ListTradableInstrumentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTradableInstrumentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ListTradableInstrumentsRequest";
  }
  protected:
  explicit ListTradableInstrumentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangeFieldNumber = 1,
  };
  // string exchange = 1;
  void clear_exchange();
  const std::string& exchange() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange();
  PROTOBUF_NODISCARD std::string* release_exchange();
  void set_allocated_exchange(std::string* exchange);
  private:
  const std::string& _internal_exchange() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const std::string& value);
  std::string* _internal_mutable_exchange();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ListTradableInstrumentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class TradableInstrumentMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.TradableInstrumentMetadata) */ {
 public:
  inline TradableInstrumentMetadata() : TradableInstrumentMetadata(nullptr) {}
  ~TradableInstrumentMetadata() override;
  explicit PROTOBUF_CONSTEXPR TradableInstrumentMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradableInstrumentMetadata(const TradableInstrumentMetadata& from);
  TradableInstrumentMetadata(TradableInstrumentMetadata&& from) noexcept
    : TradableInstrumentMetadata() {
    *this = ::std::move(from);
  }

  inline TradableInstrumentMetadata& operator=(const TradableInstrumentMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradableInstrumentMetadata& operator=(TradableInstrumentMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradableInstrumentMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradableInstrumentMetadata* internal_default_instance() {
    return reinterpret_cast<const TradableInstrumentMetadata*>(
               &_TradableInstrumentMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TradableInstrumentMetadata& a, TradableInstrumentMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TradableInstrumentMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradableInstrumentMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradableInstrumentMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradableInstrumentMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradableInstrumentMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradableInstrumentMetadata& from) {
    TradableInstrumentMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradableInstrumentMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.TradableInstrumentMetadata";
  }
  protected:
  explicit TradableInstrumentMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kPriceStepFieldNumber = 2,
    kAmountStepFieldNumber = 3,
    kMinNotionalFieldNumber = 4,
    kMinAmountFieldNumber = 5,
    kMaxAmountFieldNumber = 6,
    kMinPriceFieldNumber = 7,
    kMaxPriceFieldNumber = 8,
  };
  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // double price_step = 2;
  void clear_price_step();
  double price_step() const;
  void set_price_step(double value);
  private:
  double _internal_price_step() const;
  void _internal_set_price_step(double value);
  public:

  // double amount_step = 3;
  void clear_amount_step();
  double amount_step() const;
  void set_amount_step(double value);
  private:
  double _internal_amount_step() const;
  void _internal_set_amount_step(double value);
  public:

  // double min_notional = 4;
  void clear_min_notional();
  double min_notional() const;
  void set_min_notional(double value);
  private:
  double _internal_min_notional() const;
  void _internal_set_min_notional(double value);
  public:

  // double min_amount = 5;
  void clear_min_amount();
  double min_amount() const;
  void set_min_amount(double value);
  private:
  double _internal_min_amount() const;
  void _internal_set_min_amount(double value);
  public:

  // double max_amount = 6;
  void clear_max_amount();
  double max_amount() const;
  void set_max_amount(double value);
  private:
  double _internal_max_amount() const;
  void _internal_set_max_amount(double value);
  public:

  // double min_price = 7;
  void clear_min_price();
  double min_price() const;
  void set_min_price(double value);
  private:
  double _internal_min_price() const;
  void _internal_set_min_price(double value);
  public:

  // double max_price = 8;
  void clear_max_price();
  double max_price() const;
  void set_max_price(double value);
  private:
  double _internal_max_price() const;
  void _internal_set_max_price(double value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.TradableInstrumentMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::Instrument* instrument_;
    double price_step_;
    double amount_step_;
    double min_notional_;
    double min_amount_;
    double max_amount_;
    double min_price_;
    double max_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ListTradableInstrumentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ListTradableInstrumentsResponse) */ {
 public:
  inline ListTradableInstrumentsResponse() : ListTradableInstrumentsResponse(nullptr) {}
  ~ListTradableInstrumentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListTradableInstrumentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTradableInstrumentsResponse(const ListTradableInstrumentsResponse& from);
  ListTradableInstrumentsResponse(ListTradableInstrumentsResponse&& from) noexcept
    : ListTradableInstrumentsResponse() {
    *this = ::std::move(from);
  }

  inline ListTradableInstrumentsResponse& operator=(const ListTradableInstrumentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTradableInstrumentsResponse& operator=(ListTradableInstrumentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTradableInstrumentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTradableInstrumentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListTradableInstrumentsResponse*>(
               &_ListTradableInstrumentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListTradableInstrumentsResponse& a, ListTradableInstrumentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTradableInstrumentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTradableInstrumentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTradableInstrumentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTradableInstrumentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTradableInstrumentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTradableInstrumentsResponse& from) {
    ListTradableInstrumentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTradableInstrumentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ListTradableInstrumentsResponse";
  }
  protected:
  explicit ListTradableInstrumentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentsFieldNumber = 1,
  };
  // repeated .botcore.trading.v1.TradableInstrumentMetadata instruments = 1;
  int instruments_size() const;
  private:
  int _internal_instruments_size() const;
  public:
  void clear_instruments();
  ::botcore::trading::v1::TradableInstrumentMetadata* mutable_instruments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::TradableInstrumentMetadata >*
      mutable_instruments();
  private:
  const ::botcore::trading::v1::TradableInstrumentMetadata& _internal_instruments(int index) const;
  ::botcore::trading::v1::TradableInstrumentMetadata* _internal_add_instruments();
  public:
  const ::botcore::trading::v1::TradableInstrumentMetadata& instruments(int index) const;
  ::botcore::trading::v1::TradableInstrumentMetadata* add_instruments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::TradableInstrumentMetadata >&
      instruments() const;

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ListTradableInstrumentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::TradableInstrumentMetadata > instruments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class SubmitOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.SubmitOrderRequest) */ {
 public:
  inline SubmitOrderRequest() : SubmitOrderRequest(nullptr) {}
  ~SubmitOrderRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitOrderRequest(const SubmitOrderRequest& from);
  SubmitOrderRequest(SubmitOrderRequest&& from) noexcept
    : SubmitOrderRequest() {
    *this = ::std::move(from);
  }

  inline SubmitOrderRequest& operator=(const SubmitOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitOrderRequest& operator=(SubmitOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitOrderRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitOrderRequest*>(
               &_SubmitOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubmitOrderRequest& a, SubmitOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitOrderRequest& from) {
    SubmitOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.SubmitOrderRequest";
  }
  protected:
  explicit SubmitOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientOrderIdFieldNumber = 7,
    kInstrumentFieldNumber = 1,
    kExpiryTimeFieldNumber = 9,
    kSideFieldNumber = 2,
    kTypeFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kPriceFieldNumber = 5,
    kMaxSlippageBpsFieldNumber = 8,
    kTimeInForceFieldNumber = 6,
  };
  // string client_order_id = 7;
  void clear_client_order_id();
  const std::string& client_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_order_id();
  PROTOBUF_NODISCARD std::string* release_client_order_id();
  void set_allocated_client_order_id(std::string* client_order_id);
  private:
  const std::string& _internal_client_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_order_id(const std::string& value);
  std::string* _internal_mutable_client_order_id();
  public:

  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // .google.protobuf.Timestamp expiry_time = 9;
  bool has_expiry_time() const;
  private:
  bool _internal_has_expiry_time() const;
  public:
  void clear_expiry_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expiry_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expiry_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expiry_time();
  void set_allocated_expiry_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expiry_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expiry_time();
  public:
  void unsafe_arena_set_allocated_expiry_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expiry_time();

  // .botcore.trading.v1.OrderSide side = 2;
  void clear_side();
  ::botcore::trading::v1::OrderSide side() const;
  void set_side(::botcore::trading::v1::OrderSide value);
  private:
  ::botcore::trading::v1::OrderSide _internal_side() const;
  void _internal_set_side(::botcore::trading::v1::OrderSide value);
  public:

  // .botcore.trading.v1.OrderType type = 3;
  void clear_type();
  ::botcore::trading::v1::OrderType type() const;
  void set_type(::botcore::trading::v1::OrderType value);
  private:
  ::botcore::trading::v1::OrderType _internal_type() const;
  void _internal_set_type(::botcore::trading::v1::OrderType value);
  public:

  // double quantity = 4;
  void clear_quantity();
  double quantity() const;
  void set_quantity(double value);
  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);
  public:

  // double price = 5;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // double max_slippage_bps = 8;
  void clear_max_slippage_bps();
  double max_slippage_bps() const;
  void set_max_slippage_bps(double value);
  private:
  double _internal_max_slippage_bps() const;
  void _internal_set_max_slippage_bps(double value);
  public:

  // .botcore.trading.v1.TimeInForce time_in_force = 6;
  void clear_time_in_force();
  ::botcore::trading::v1::TimeInForce time_in_force() const;
  void set_time_in_force(::botcore::trading::v1::TimeInForce value);
  private:
  ::botcore::trading::v1::TimeInForce _internal_time_in_force() const;
  void _internal_set_time_in_force(::botcore::trading::v1::TimeInForce value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.SubmitOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_order_id_;
    ::botcore::trading::v1::Instrument* instrument_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_time_;
    int side_;
    int type_;
    double quantity_;
    double price_;
    double max_slippage_bps_;
    int time_in_force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class SubmitOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.SubmitOrderResponse) */ {
 public:
  inline SubmitOrderResponse() : SubmitOrderResponse(nullptr) {}
  ~SubmitOrderResponse() override;
  explicit PROTOBUF_CONSTEXPR SubmitOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitOrderResponse(const SubmitOrderResponse& from);
  SubmitOrderResponse(SubmitOrderResponse&& from) noexcept
    : SubmitOrderResponse() {
    *this = ::std::move(from);
  }

  inline SubmitOrderResponse& operator=(const SubmitOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitOrderResponse& operator=(SubmitOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitOrderResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitOrderResponse*>(
               &_SubmitOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SubmitOrderResponse& a, SubmitOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitOrderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitOrderResponse& from) {
    SubmitOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.SubmitOrderResponse";
  }
  protected:
  explicit SubmitOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViolationsFieldNumber = 4,
    kOrderIdFieldNumber = 1,
    kExternalOrderIdFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // repeated .botcore.trading.v1.OrderConstraintViolation violations = 4;
  int violations_size() const;
  private:
  int _internal_violations_size() const;
  public:
  void clear_violations();
  ::botcore::trading::v1::OrderConstraintViolation* mutable_violations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OrderConstraintViolation >*
      mutable_violations();
  private:
  const ::botcore::trading::v1::OrderConstraintViolation& _internal_violations(int index) const;
  ::botcore::trading::v1::OrderConstraintViolation* _internal_add_violations();
  public:
  const ::botcore::trading::v1::OrderConstraintViolation& violations(int index) const;
  ::botcore::trading::v1::OrderConstraintViolation* add_violations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OrderConstraintViolation >&
      violations() const;

  // string order_id = 1;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string external_order_id = 2;
  void clear_external_order_id();
  const std::string& external_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_order_id();
  PROTOBUF_NODISCARD std::string* release_external_order_id();
  void set_allocated_external_order_id(std::string* external_order_id);
  private:
  const std::string& _internal_external_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_order_id(const std::string& value);
  std::string* _internal_mutable_external_order_id();
  public:

  // .botcore.trading.v1.OrderStatus status = 3;
  void clear_status();
  ::botcore::trading::v1::OrderStatus status() const;
  void set_status(::botcore::trading::v1::OrderStatus value);
  private:
  ::botcore::trading::v1::OrderStatus _internal_status() const;
  void _internal_set_status(::botcore::trading::v1::OrderStatus value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.SubmitOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OrderConstraintViolation > violations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_order_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class OrderConstraintViolation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.OrderConstraintViolation) */ {
 public:
  inline OrderConstraintViolation() : OrderConstraintViolation(nullptr) {}
  ~OrderConstraintViolation() override;
  explicit PROTOBUF_CONSTEXPR OrderConstraintViolation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderConstraintViolation(const OrderConstraintViolation& from);
  OrderConstraintViolation(OrderConstraintViolation&& from) noexcept
    : OrderConstraintViolation() {
    *this = ::std::move(from);
  }

  inline OrderConstraintViolation& operator=(const OrderConstraintViolation& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderConstraintViolation& operator=(OrderConstraintViolation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderConstraintViolation& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderConstraintViolation* internal_default_instance() {
    return reinterpret_cast<const OrderConstraintViolation*>(
               &_OrderConstraintViolation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(OrderConstraintViolation& a, OrderConstraintViolation& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderConstraintViolation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderConstraintViolation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderConstraintViolation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderConstraintViolation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderConstraintViolation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderConstraintViolation& from) {
    OrderConstraintViolation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderConstraintViolation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.OrderConstraintViolation";
  }
  protected:
  explicit OrderConstraintViolation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.OrderConstraintViolation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class CancelOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.CancelOrderRequest) */ {
 public:
  inline CancelOrderRequest() : CancelOrderRequest(nullptr) {}
  ~CancelOrderRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrderRequest(const CancelOrderRequest& from);
  CancelOrderRequest(CancelOrderRequest&& from) noexcept
    : CancelOrderRequest() {
    *this = ::std::move(from);
  }

  inline CancelOrderRequest& operator=(const CancelOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrderRequest& operator=(CancelOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrderRequest* internal_default_instance() {
    return reinterpret_cast<const CancelOrderRequest*>(
               &_CancelOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CancelOrderRequest& a, CancelOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelOrderRequest& from) {
    CancelOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.CancelOrderRequest";
  }
  protected:
  explicit CancelOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 2,
    kClientOrderIdFieldNumber = 3,
    kInstrumentFieldNumber = 1,
  };
  // string order_id = 2;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string client_order_id = 3;
  void clear_client_order_id();
  const std::string& client_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_order_id();
  PROTOBUF_NODISCARD std::string* release_client_order_id();
  void set_allocated_client_order_id(std::string* client_order_id);
  private:
  const std::string& _internal_client_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_order_id(const std::string& value);
  std::string* _internal_mutable_client_order_id();
  public:

  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.CancelOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_order_id_;
    ::botcore::trading::v1::Instrument* instrument_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class CancelOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.CancelOrderResponse) */ {
 public:
  inline CancelOrderResponse() : CancelOrderResponse(nullptr) {}
  ~CancelOrderResponse() override;
  explicit PROTOBUF_CONSTEXPR CancelOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrderResponse(const CancelOrderResponse& from);
  CancelOrderResponse(CancelOrderResponse&& from) noexcept
    : CancelOrderResponse() {
    *this = ::std::move(from);
  }

  inline CancelOrderResponse& operator=(const CancelOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrderResponse& operator=(CancelOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrderResponse* internal_default_instance() {
    return reinterpret_cast<const CancelOrderResponse*>(
               &_CancelOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CancelOrderResponse& a, CancelOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelOrderResponse& from) {
    CancelOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.CancelOrderResponse";
  }
  protected:
  explicit CancelOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .botcore.trading.v1.OrderStatus status = 1;
  void clear_status();
  ::botcore::trading::v1::OrderStatus status() const;
  void set_status(::botcore::trading::v1::OrderStatus value);
  private:
  ::botcore::trading::v1::OrderStatus _internal_status() const;
  void _internal_set_status(::botcore::trading::v1::OrderStatus value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.CancelOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class RiskStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.RiskStateRequest) */ {
 public:
  inline RiskStateRequest() : RiskStateRequest(nullptr) {}
  ~RiskStateRequest() override;
  explicit PROTOBUF_CONSTEXPR RiskStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RiskStateRequest(const RiskStateRequest& from);
  RiskStateRequest(RiskStateRequest&& from) noexcept
    : RiskStateRequest() {
    *this = ::std::move(from);
  }

  inline RiskStateRequest& operator=(const RiskStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RiskStateRequest& operator=(RiskStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RiskStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RiskStateRequest* internal_default_instance() {
    return reinterpret_cast<const RiskStateRequest*>(
               &_RiskStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RiskStateRequest& a, RiskStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RiskStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RiskStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RiskStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RiskStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RiskStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RiskStateRequest& from) {
    RiskStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RiskStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.RiskStateRequest";
  }
  protected:
  explicit RiskStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
  };
  // .botcore.trading.v1.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::botcore::trading::v1::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::Instrument* release_instrument();
  ::botcore::trading::v1::Instrument* mutable_instrument();
  void set_allocated_instrument(::botcore::trading::v1::Instrument* instrument);
  private:
  const ::botcore::trading::v1::Instrument& _internal_instrument() const;
  ::botcore::trading::v1::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::botcore::trading::v1::Instrument* instrument);
  ::botcore::trading::v1::Instrument* unsafe_arena_release_instrument();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.RiskStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::Instrument* instrument_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ExposureLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ExposureLimit) */ {
 public:
  inline ExposureLimit() : ExposureLimit(nullptr) {}
  ~ExposureLimit() override;
  explicit PROTOBUF_CONSTEXPR ExposureLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExposureLimit(const ExposureLimit& from);
  ExposureLimit(ExposureLimit&& from) noexcept
    : ExposureLimit() {
    *this = ::std::move(from);
  }

  inline ExposureLimit& operator=(const ExposureLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExposureLimit& operator=(ExposureLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExposureLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExposureLimit* internal_default_instance() {
    return reinterpret_cast<const ExposureLimit*>(
               &_ExposureLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ExposureLimit& a, ExposureLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(ExposureLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExposureLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExposureLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExposureLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExposureLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExposureLimit& from) {
    ExposureLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExposureLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ExposureLimit";
  }
  protected:
  explicit ExposureLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kMaxValueFieldNumber = 2,
    kCurrentValueFieldNumber = 3,
    kThresholdValueFieldNumber = 4,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // double max_value = 2;
  void clear_max_value();
  double max_value() const;
  void set_max_value(double value);
  private:
  double _internal_max_value() const;
  void _internal_set_max_value(double value);
  public:

  // double current_value = 3;
  void clear_current_value();
  double current_value() const;
  void set_current_value(double value);
  private:
  double _internal_current_value() const;
  void _internal_set_current_value(double value);
  public:

  // double threshold_value = 4;
  void clear_threshold_value();
  double threshold_value() const;
  void set_threshold_value(double value);
  private:
  double _internal_threshold_value() const;
  void _internal_set_threshold_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ExposureLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    double max_value_;
    double current_value_;
    double threshold_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class RiskState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.RiskState) */ {
 public:
  inline RiskState() : RiskState(nullptr) {}
  ~RiskState() override;
  explicit PROTOBUF_CONSTEXPR RiskState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RiskState(const RiskState& from);
  RiskState(RiskState&& from) noexcept
    : RiskState() {
    *this = ::std::move(from);
  }

  inline RiskState& operator=(const RiskState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RiskState& operator=(RiskState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RiskState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RiskState* internal_default_instance() {
    return reinterpret_cast<const RiskState*>(
               &_RiskState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RiskState& a, RiskState& b) {
    a.Swap(&b);
  }
  inline void Swap(RiskState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RiskState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RiskState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RiskState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RiskState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RiskState& from) {
    RiskState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RiskState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.RiskState";
  }
  protected:
  explicit RiskState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitsFieldNumber = 6,
    kGeneratedAtFieldNumber = 7,
    kPortfolioValueFieldNumber = 2,
    kCurrentDrawdownFieldNumber = 3,
    kMaxDailyLossFieldNumber = 4,
    kUsedLeverageFieldNumber = 5,
    kProfileFieldNumber = 1,
  };
  // repeated .botcore.trading.v1.ExposureLimit limits = 6;
  int limits_size() const;
  private:
  int _internal_limits_size() const;
  public:
  void clear_limits();
  ::botcore::trading::v1::ExposureLimit* mutable_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::ExposureLimit >*
      mutable_limits();
  private:
  const ::botcore::trading::v1::ExposureLimit& _internal_limits(int index) const;
  ::botcore::trading::v1::ExposureLimit* _internal_add_limits();
  public:
  const ::botcore::trading::v1::ExposureLimit& limits(int index) const;
  ::botcore::trading::v1::ExposureLimit* add_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::ExposureLimit >&
      limits() const;

  // .google.protobuf.Timestamp generated_at = 7;
  bool has_generated_at() const;
  private:
  bool _internal_has_generated_at() const;
  public:
  void clear_generated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& generated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_generated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_generated_at();
  void set_allocated_generated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_generated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_generated_at();
  public:
  void unsafe_arena_set_allocated_generated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_generated_at();

  // double portfolio_value = 2;
  void clear_portfolio_value();
  double portfolio_value() const;
  void set_portfolio_value(double value);
  private:
  double _internal_portfolio_value() const;
  void _internal_set_portfolio_value(double value);
  public:

  // double current_drawdown = 3;
  void clear_current_drawdown();
  double current_drawdown() const;
  void set_current_drawdown(double value);
  private:
  double _internal_current_drawdown() const;
  void _internal_set_current_drawdown(double value);
  public:

  // double max_daily_loss = 4;
  void clear_max_daily_loss();
  double max_daily_loss() const;
  void set_max_daily_loss(double value);
  private:
  double _internal_max_daily_loss() const;
  void _internal_set_max_daily_loss(double value);
  public:

  // double used_leverage = 5;
  void clear_used_leverage();
  double used_leverage() const;
  void set_used_leverage(double value);
  private:
  double _internal_used_leverage() const;
  void _internal_set_used_leverage(double value);
  public:

  // .botcore.trading.v1.RiskProfile profile = 1;
  void clear_profile();
  ::botcore::trading::v1::RiskProfile profile() const;
  void set_profile(::botcore::trading::v1::RiskProfile value);
  private:
  ::botcore::trading::v1::RiskProfile _internal_profile() const;
  void _internal_set_profile(::botcore::trading::v1::RiskProfile value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.RiskState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::ExposureLimit > limits_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at_;
    double portfolio_value_;
    double current_drawdown_;
    double max_daily_loss_;
    double used_leverage_;
    int profile_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class MetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.MetricsRequest) */ {
 public:
  inline MetricsRequest() : MetricsRequest(nullptr) {}
  ~MetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR MetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsRequest(const MetricsRequest& from);
  MetricsRequest(MetricsRequest&& from) noexcept
    : MetricsRequest() {
    *this = ::std::move(from);
  }

  inline MetricsRequest& operator=(const MetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsRequest& operator=(MetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsRequest* internal_default_instance() {
    return reinterpret_cast<const MetricsRequest*>(
               &_MetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MetricsRequest& a, MetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricsRequest& from) {
    MetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.MetricsRequest";
  }
  protected:
  explicit MetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeUiMetricsFieldNumber = 1,
  };
  // bool include_ui_metrics = 1;
  void clear_include_ui_metrics();
  bool include_ui_metrics() const;
  void set_include_ui_metrics(bool value);
  private:
  bool _internal_include_ui_metrics() const;
  void _internal_set_include_ui_metrics(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.MetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool include_ui_metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class MetricsSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.MetricsSnapshot) */ {
 public:
  inline MetricsSnapshot() : MetricsSnapshot(nullptr) {}
  ~MetricsSnapshot() override;
  explicit PROTOBUF_CONSTEXPR MetricsSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsSnapshot(const MetricsSnapshot& from);
  MetricsSnapshot(MetricsSnapshot&& from) noexcept
    : MetricsSnapshot() {
    *this = ::std::move(from);
  }

  inline MetricsSnapshot& operator=(const MetricsSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsSnapshot& operator=(MetricsSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsSnapshot* internal_default_instance() {
    return reinterpret_cast<const MetricsSnapshot*>(
               &_MetricsSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MetricsSnapshot& a, MetricsSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricsSnapshot& from) {
    MetricsSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.MetricsSnapshot";
  }
  protected:
  explicit MetricsSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotesFieldNumber = 9,
    kGeneratedAtFieldNumber = 1,
    kEventToFrameP95MsFieldNumber = 2,
    kFpsFieldNumber = 3,
    kCpuUtilizationFieldNumber = 4,
    kGpuUtilizationFieldNumber = 5,
    kRamMegabytesFieldNumber = 6,
    kDroppedFramesFieldNumber = 7,
    kProcessedMessagesPerSecondFieldNumber = 8,
  };
  // string notes = 9;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .google.protobuf.Timestamp generated_at = 1;
  bool has_generated_at() const;
  private:
  bool _internal_has_generated_at() const;
  public:
  void clear_generated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& generated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_generated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_generated_at();
  void set_allocated_generated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_generated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_generated_at();
  public:
  void unsafe_arena_set_allocated_generated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_generated_at();

  // double event_to_frame_p95_ms = 2;
  void clear_event_to_frame_p95_ms();
  double event_to_frame_p95_ms() const;
  void set_event_to_frame_p95_ms(double value);
  private:
  double _internal_event_to_frame_p95_ms() const;
  void _internal_set_event_to_frame_p95_ms(double value);
  public:

  // double fps = 3;
  void clear_fps();
  double fps() const;
  void set_fps(double value);
  private:
  double _internal_fps() const;
  void _internal_set_fps(double value);
  public:

  // double cpu_utilization = 4;
  void clear_cpu_utilization();
  double cpu_utilization() const;
  void set_cpu_utilization(double value);
  private:
  double _internal_cpu_utilization() const;
  void _internal_set_cpu_utilization(double value);
  public:

  // double gpu_utilization = 5;
  void clear_gpu_utilization();
  double gpu_utilization() const;
  void set_gpu_utilization(double value);
  private:
  double _internal_gpu_utilization() const;
  void _internal_set_gpu_utilization(double value);
  public:

  // double ram_megabytes = 6;
  void clear_ram_megabytes();
  double ram_megabytes() const;
  void set_ram_megabytes(double value);
  private:
  double _internal_ram_megabytes() const;
  void _internal_set_ram_megabytes(double value);
  public:

  // uint64 dropped_frames = 7;
  void clear_dropped_frames();
  uint64_t dropped_frames() const;
  void set_dropped_frames(uint64_t value);
  private:
  uint64_t _internal_dropped_frames() const;
  void _internal_set_dropped_frames(uint64_t value);
  public:

  // uint64 processed_messages_per_second = 8;
  void clear_processed_messages_per_second();
  uint64_t processed_messages_per_second() const;
  void set_processed_messages_per_second(uint64_t value);
  private:
  uint64_t _internal_processed_messages_per_second() const;
  void _internal_set_processed_messages_per_second(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.MetricsSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at_;
    double event_to_frame_p95_ms_;
    double fps_;
    double cpu_utilization_;
    double gpu_utilization_;
    double ram_megabytes_;
    uint64_t dropped_frames_;
    uint64_t processed_messages_per_second_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class MetricsAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.MetricsAck) */ {
 public:
  inline MetricsAck() : MetricsAck(nullptr) {}
  ~MetricsAck() override;
  explicit PROTOBUF_CONSTEXPR MetricsAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsAck(const MetricsAck& from);
  MetricsAck(MetricsAck&& from) noexcept
    : MetricsAck() {
    *this = ::std::move(from);
  }

  inline MetricsAck& operator=(const MetricsAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsAck& operator=(MetricsAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsAck* internal_default_instance() {
    return reinterpret_cast<const MetricsAck*>(
               &_MetricsAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MetricsAck& a, MetricsAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricsAck& from) {
    MetricsAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.MetricsAck";
  }
  protected:
  explicit MetricsAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // bool accepted = 1;
  void clear_accepted();
  bool accepted() const;
  void set_accepted(bool value);
  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.MetricsAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool accepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:botcore.trading.v1.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kGitCommitFieldNumber = 2,
    kStartedAtFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string git_commit = 2;
  void clear_git_commit();
  const std::string& git_commit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_git_commit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_git_commit();
  PROTOBUF_NODISCARD std::string* release_git_commit();
  void set_allocated_git_commit(std::string* git_commit);
  private:
  const std::string& _internal_git_commit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_commit(const std::string& value);
  std::string* _internal_mutable_git_commit();
  public:

  // .google.protobuf.Timestamp started_at = 3;
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr git_commit_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class MarketplacePresetSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.MarketplacePresetSummary) */ {
 public:
  inline MarketplacePresetSummary() : MarketplacePresetSummary(nullptr) {}
  ~MarketplacePresetSummary() override;
  explicit PROTOBUF_CONSTEXPR MarketplacePresetSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketplacePresetSummary(const MarketplacePresetSummary& from);
  MarketplacePresetSummary(MarketplacePresetSummary&& from) noexcept
    : MarketplacePresetSummary() {
    *this = ::std::move(from);
  }

  inline MarketplacePresetSummary& operator=(const MarketplacePresetSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketplacePresetSummary& operator=(MarketplacePresetSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketplacePresetSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketplacePresetSummary* internal_default_instance() {
    return reinterpret_cast<const MarketplacePresetSummary*>(
               &_MarketplacePresetSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MarketplacePresetSummary& a, MarketplacePresetSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketplacePresetSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketplacePresetSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketplacePresetSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketplacePresetSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketplacePresetSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketplacePresetSummary& from) {
    MarketplacePresetSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketplacePresetSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.MarketplacePresetSummary";
  }
  protected:
  explicit MarketplacePresetSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kIssuesFieldNumber = 8,
    kPresetIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 3,
    kProfileFieldNumber = 4,
    kSourcePathFieldNumber = 7,
    kSignatureVerifiedFieldNumber = 6,
  };
  // repeated string tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated string issues = 8;
  int issues_size() const;
  private:
  int _internal_issues_size() const;
  public:
  void clear_issues();
  const std::string& issues(int index) const;
  std::string* mutable_issues(int index);
  void set_issues(int index, const std::string& value);
  void set_issues(int index, std::string&& value);
  void set_issues(int index, const char* value);
  void set_issues(int index, const char* value, size_t size);
  std::string* add_issues();
  void add_issues(const std::string& value);
  void add_issues(std::string&& value);
  void add_issues(const char* value);
  void add_issues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& issues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_issues();
  private:
  const std::string& _internal_issues(int index) const;
  std::string* _internal_add_issues();
  public:

  // string preset_id = 1;
  void clear_preset_id();
  const std::string& preset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preset_id();
  PROTOBUF_NODISCARD std::string* release_preset_id();
  void set_allocated_preset_id(std::string* preset_id);
  private:
  const std::string& _internal_preset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset_id(const std::string& value);
  std::string* _internal_mutable_preset_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string profile = 4;
  void clear_profile();
  const std::string& profile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profile();
  PROTOBUF_NODISCARD std::string* release_profile();
  void set_allocated_profile(std::string* profile);
  private:
  const std::string& _internal_profile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile(const std::string& value);
  std::string* _internal_mutable_profile();
  public:

  // string source_path = 7;
  void clear_source_path();
  const std::string& source_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_path();
  PROTOBUF_NODISCARD std::string* release_source_path();
  void set_allocated_source_path(std::string* source_path);
  private:
  const std::string& _internal_source_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_path(const std::string& value);
  std::string* _internal_mutable_source_path();
  public:

  // bool signature_verified = 6;
  void clear_signature_verified();
  bool signature_verified() const;
  void set_signature_verified(bool value);
  private:
  bool _internal_signature_verified() const;
  void _internal_set_signature_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.MarketplacePresetSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> issues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_path_;
    bool signature_verified_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ListMarketplacePresetsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ListMarketplacePresetsRequest) */ {
 public:
  inline ListMarketplacePresetsRequest() : ListMarketplacePresetsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListMarketplacePresetsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMarketplacePresetsRequest(const ListMarketplacePresetsRequest& from);
  ListMarketplacePresetsRequest(ListMarketplacePresetsRequest&& from) noexcept
    : ListMarketplacePresetsRequest() {
    *this = ::std::move(from);
  }

  inline ListMarketplacePresetsRequest& operator=(const ListMarketplacePresetsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMarketplacePresetsRequest& operator=(ListMarketplacePresetsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMarketplacePresetsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMarketplacePresetsRequest* internal_default_instance() {
    return reinterpret_cast<const ListMarketplacePresetsRequest*>(
               &_ListMarketplacePresetsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ListMarketplacePresetsRequest& a, ListMarketplacePresetsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMarketplacePresetsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMarketplacePresetsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMarketplacePresetsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMarketplacePresetsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListMarketplacePresetsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListMarketplacePresetsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ListMarketplacePresetsRequest";
  }
  protected:
  explicit ListMarketplacePresetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ListMarketplacePresetsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ListMarketplacePresetsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ListMarketplacePresetsResponse) */ {
 public:
  inline ListMarketplacePresetsResponse() : ListMarketplacePresetsResponse(nullptr) {}
  ~ListMarketplacePresetsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListMarketplacePresetsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMarketplacePresetsResponse(const ListMarketplacePresetsResponse& from);
  ListMarketplacePresetsResponse(ListMarketplacePresetsResponse&& from) noexcept
    : ListMarketplacePresetsResponse() {
    *this = ::std::move(from);
  }

  inline ListMarketplacePresetsResponse& operator=(const ListMarketplacePresetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMarketplacePresetsResponse& operator=(ListMarketplacePresetsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMarketplacePresetsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMarketplacePresetsResponse* internal_default_instance() {
    return reinterpret_cast<const ListMarketplacePresetsResponse*>(
               &_ListMarketplacePresetsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListMarketplacePresetsResponse& a, ListMarketplacePresetsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMarketplacePresetsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMarketplacePresetsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMarketplacePresetsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMarketplacePresetsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMarketplacePresetsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMarketplacePresetsResponse& from) {
    ListMarketplacePresetsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMarketplacePresetsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ListMarketplacePresetsResponse";
  }
  protected:
  explicit ListMarketplacePresetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetsFieldNumber = 1,
  };
  // repeated .botcore.trading.v1.MarketplacePresetSummary presets = 1;
  int presets_size() const;
  private:
  int _internal_presets_size() const;
  public:
  void clear_presets();
  ::botcore::trading::v1::MarketplacePresetSummary* mutable_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::MarketplacePresetSummary >*
      mutable_presets();
  private:
  const ::botcore::trading::v1::MarketplacePresetSummary& _internal_presets(int index) const;
  ::botcore::trading::v1::MarketplacePresetSummary* _internal_add_presets();
  public:
  const ::botcore::trading::v1::MarketplacePresetSummary& presets(int index) const;
  ::botcore::trading::v1::MarketplacePresetSummary* add_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::MarketplacePresetSummary >&
      presets() const;

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ListMarketplacePresetsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::MarketplacePresetSummary > presets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ImportMarketplacePresetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ImportMarketplacePresetRequest) */ {
 public:
  inline ImportMarketplacePresetRequest() : ImportMarketplacePresetRequest(nullptr) {}
  ~ImportMarketplacePresetRequest() override;
  explicit PROTOBUF_CONSTEXPR ImportMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportMarketplacePresetRequest(const ImportMarketplacePresetRequest& from);
  ImportMarketplacePresetRequest(ImportMarketplacePresetRequest&& from) noexcept
    : ImportMarketplacePresetRequest() {
    *this = ::std::move(from);
  }

  inline ImportMarketplacePresetRequest& operator=(const ImportMarketplacePresetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportMarketplacePresetRequest& operator=(ImportMarketplacePresetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportMarketplacePresetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportMarketplacePresetRequest* internal_default_instance() {
    return reinterpret_cast<const ImportMarketplacePresetRequest*>(
               &_ImportMarketplacePresetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ImportMarketplacePresetRequest& a, ImportMarketplacePresetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportMarketplacePresetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportMarketplacePresetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportMarketplacePresetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportMarketplacePresetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportMarketplacePresetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportMarketplacePresetRequest& from) {
    ImportMarketplacePresetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportMarketplacePresetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ImportMarketplacePresetRequest";
  }
  protected:
  explicit ImportMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kFilenameFieldNumber = 2,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string filename = 2;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ImportMarketplacePresetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ImportMarketplacePresetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ImportMarketplacePresetResponse) */ {
 public:
  inline ImportMarketplacePresetResponse() : ImportMarketplacePresetResponse(nullptr) {}
  ~ImportMarketplacePresetResponse() override;
  explicit PROTOBUF_CONSTEXPR ImportMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportMarketplacePresetResponse(const ImportMarketplacePresetResponse& from);
  ImportMarketplacePresetResponse(ImportMarketplacePresetResponse&& from) noexcept
    : ImportMarketplacePresetResponse() {
    *this = ::std::move(from);
  }

  inline ImportMarketplacePresetResponse& operator=(const ImportMarketplacePresetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportMarketplacePresetResponse& operator=(ImportMarketplacePresetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportMarketplacePresetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportMarketplacePresetResponse* internal_default_instance() {
    return reinterpret_cast<const ImportMarketplacePresetResponse*>(
               &_ImportMarketplacePresetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ImportMarketplacePresetResponse& a, ImportMarketplacePresetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportMarketplacePresetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportMarketplacePresetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportMarketplacePresetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportMarketplacePresetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportMarketplacePresetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportMarketplacePresetResponse& from) {
    ImportMarketplacePresetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportMarketplacePresetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ImportMarketplacePresetResponse";
  }
  protected:
  explicit ImportMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetFieldNumber = 1,
  };
  // .botcore.trading.v1.MarketplacePresetSummary preset = 1;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  const ::botcore::trading::v1::MarketplacePresetSummary& preset() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::MarketplacePresetSummary* release_preset();
  ::botcore::trading::v1::MarketplacePresetSummary* mutable_preset();
  void set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset);
  private:
  const ::botcore::trading::v1::MarketplacePresetSummary& _internal_preset() const;
  ::botcore::trading::v1::MarketplacePresetSummary* _internal_mutable_preset();
  public:
  void unsafe_arena_set_allocated_preset(
      ::botcore::trading::v1::MarketplacePresetSummary* preset);
  ::botcore::trading::v1::MarketplacePresetSummary* unsafe_arena_release_preset();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ImportMarketplacePresetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::MarketplacePresetSummary* preset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ExportMarketplacePresetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ExportMarketplacePresetRequest) */ {
 public:
  inline ExportMarketplacePresetRequest() : ExportMarketplacePresetRequest(nullptr) {}
  ~ExportMarketplacePresetRequest() override;
  explicit PROTOBUF_CONSTEXPR ExportMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportMarketplacePresetRequest(const ExportMarketplacePresetRequest& from);
  ExportMarketplacePresetRequest(ExportMarketplacePresetRequest&& from) noexcept
    : ExportMarketplacePresetRequest() {
    *this = ::std::move(from);
  }

  inline ExportMarketplacePresetRequest& operator=(const ExportMarketplacePresetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportMarketplacePresetRequest& operator=(ExportMarketplacePresetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportMarketplacePresetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportMarketplacePresetRequest* internal_default_instance() {
    return reinterpret_cast<const ExportMarketplacePresetRequest*>(
               &_ExportMarketplacePresetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ExportMarketplacePresetRequest& a, ExportMarketplacePresetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportMarketplacePresetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportMarketplacePresetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportMarketplacePresetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportMarketplacePresetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportMarketplacePresetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExportMarketplacePresetRequest& from) {
    ExportMarketplacePresetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportMarketplacePresetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ExportMarketplacePresetRequest";
  }
  protected:
  explicit ExportMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetIdFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // string preset_id = 1;
  void clear_preset_id();
  const std::string& preset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preset_id();
  PROTOBUF_NODISCARD std::string* release_preset_id();
  void set_allocated_preset_id(std::string* preset_id);
  private:
  const std::string& _internal_preset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset_id(const std::string& value);
  std::string* _internal_mutable_preset_id();
  public:

  // string format = 2;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ExportMarketplacePresetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ExportMarketplacePresetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ExportMarketplacePresetResponse) */ {
 public:
  inline ExportMarketplacePresetResponse() : ExportMarketplacePresetResponse(nullptr) {}
  ~ExportMarketplacePresetResponse() override;
  explicit PROTOBUF_CONSTEXPR ExportMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportMarketplacePresetResponse(const ExportMarketplacePresetResponse& from);
  ExportMarketplacePresetResponse(ExportMarketplacePresetResponse&& from) noexcept
    : ExportMarketplacePresetResponse() {
    *this = ::std::move(from);
  }

  inline ExportMarketplacePresetResponse& operator=(const ExportMarketplacePresetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportMarketplacePresetResponse& operator=(ExportMarketplacePresetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportMarketplacePresetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportMarketplacePresetResponse* internal_default_instance() {
    return reinterpret_cast<const ExportMarketplacePresetResponse*>(
               &_ExportMarketplacePresetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ExportMarketplacePresetResponse& a, ExportMarketplacePresetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportMarketplacePresetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportMarketplacePresetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportMarketplacePresetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportMarketplacePresetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportMarketplacePresetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExportMarketplacePresetResponse& from) {
    ExportMarketplacePresetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportMarketplacePresetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ExportMarketplacePresetResponse";
  }
  protected:
  explicit ExportMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kFilenameFieldNumber = 2,
    kFormatFieldNumber = 4,
    kPresetFieldNumber = 3,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string filename = 2;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string format = 4;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // .botcore.trading.v1.MarketplacePresetSummary preset = 3;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  const ::botcore::trading::v1::MarketplacePresetSummary& preset() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::MarketplacePresetSummary* release_preset();
  ::botcore::trading::v1::MarketplacePresetSummary* mutable_preset();
  void set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset);
  private:
  const ::botcore::trading::v1::MarketplacePresetSummary& _internal_preset() const;
  ::botcore::trading::v1::MarketplacePresetSummary* _internal_mutable_preset();
  public:
  void unsafe_arena_set_allocated_preset(
      ::botcore::trading::v1::MarketplacePresetSummary* preset);
  ::botcore::trading::v1::MarketplacePresetSummary* unsafe_arena_release_preset();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ExportMarketplacePresetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::botcore::trading::v1::MarketplacePresetSummary* preset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class RemoveMarketplacePresetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.RemoveMarketplacePresetRequest) */ {
 public:
  inline RemoveMarketplacePresetRequest() : RemoveMarketplacePresetRequest(nullptr) {}
  ~RemoveMarketplacePresetRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveMarketplacePresetRequest(const RemoveMarketplacePresetRequest& from);
  RemoveMarketplacePresetRequest(RemoveMarketplacePresetRequest&& from) noexcept
    : RemoveMarketplacePresetRequest() {
    *this = ::std::move(from);
  }

  inline RemoveMarketplacePresetRequest& operator=(const RemoveMarketplacePresetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMarketplacePresetRequest& operator=(RemoveMarketplacePresetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveMarketplacePresetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveMarketplacePresetRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveMarketplacePresetRequest*>(
               &_RemoveMarketplacePresetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RemoveMarketplacePresetRequest& a, RemoveMarketplacePresetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMarketplacePresetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMarketplacePresetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveMarketplacePresetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveMarketplacePresetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveMarketplacePresetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveMarketplacePresetRequest& from) {
    RemoveMarketplacePresetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMarketplacePresetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.RemoveMarketplacePresetRequest";
  }
  protected:
  explicit RemoveMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetIdFieldNumber = 1,
  };
  // string preset_id = 1;
  void clear_preset_id();
  const std::string& preset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preset_id();
  PROTOBUF_NODISCARD std::string* release_preset_id();
  void set_allocated_preset_id(std::string* preset_id);
  private:
  const std::string& _internal_preset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset_id(const std::string& value);
  std::string* _internal_mutable_preset_id();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.RemoveMarketplacePresetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class RemoveMarketplacePresetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.RemoveMarketplacePresetResponse) */ {
 public:
  inline RemoveMarketplacePresetResponse() : RemoveMarketplacePresetResponse(nullptr) {}
  ~RemoveMarketplacePresetResponse() override;
  explicit PROTOBUF_CONSTEXPR RemoveMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveMarketplacePresetResponse(const RemoveMarketplacePresetResponse& from);
  RemoveMarketplacePresetResponse(RemoveMarketplacePresetResponse&& from) noexcept
    : RemoveMarketplacePresetResponse() {
    *this = ::std::move(from);
  }

  inline RemoveMarketplacePresetResponse& operator=(const RemoveMarketplacePresetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMarketplacePresetResponse& operator=(RemoveMarketplacePresetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveMarketplacePresetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveMarketplacePresetResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveMarketplacePresetResponse*>(
               &_RemoveMarketplacePresetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RemoveMarketplacePresetResponse& a, RemoveMarketplacePresetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMarketplacePresetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMarketplacePresetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveMarketplacePresetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveMarketplacePresetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveMarketplacePresetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveMarketplacePresetResponse& from) {
    RemoveMarketplacePresetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMarketplacePresetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.RemoveMarketplacePresetResponse";
  }
  protected:
  explicit RemoveMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemovedFieldNumber = 1,
  };
  // bool removed = 1;
  void clear_removed();
  bool removed() const;
  void set_removed(bool value);
  private:
  bool _internal_removed() const;
  void _internal_set_removed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.RemoveMarketplacePresetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool removed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ActivateMarketplacePresetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ActivateMarketplacePresetRequest) */ {
 public:
  inline ActivateMarketplacePresetRequest() : ActivateMarketplacePresetRequest(nullptr) {}
  ~ActivateMarketplacePresetRequest() override;
  explicit PROTOBUF_CONSTEXPR ActivateMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivateMarketplacePresetRequest(const ActivateMarketplacePresetRequest& from);
  ActivateMarketplacePresetRequest(ActivateMarketplacePresetRequest&& from) noexcept
    : ActivateMarketplacePresetRequest() {
    *this = ::std::move(from);
  }

  inline ActivateMarketplacePresetRequest& operator=(const ActivateMarketplacePresetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateMarketplacePresetRequest& operator=(ActivateMarketplacePresetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateMarketplacePresetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateMarketplacePresetRequest* internal_default_instance() {
    return reinterpret_cast<const ActivateMarketplacePresetRequest*>(
               &_ActivateMarketplacePresetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ActivateMarketplacePresetRequest& a, ActivateMarketplacePresetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateMarketplacePresetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateMarketplacePresetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateMarketplacePresetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivateMarketplacePresetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivateMarketplacePresetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivateMarketplacePresetRequest& from) {
    ActivateMarketplacePresetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateMarketplacePresetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ActivateMarketplacePresetRequest";
  }
  protected:
  explicit ActivateMarketplacePresetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetIdFieldNumber = 1,
  };
  // string preset_id = 1;
  void clear_preset_id();
  const std::string& preset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preset_id();
  PROTOBUF_NODISCARD std::string* release_preset_id();
  void set_allocated_preset_id(std::string* preset_id);
  private:
  const std::string& _internal_preset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset_id(const std::string& value);
  std::string* _internal_mutable_preset_id();
  public:

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ActivateMarketplacePresetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ActivateMarketplacePresetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:botcore.trading.v1.ActivateMarketplacePresetResponse) */ {
 public:
  inline ActivateMarketplacePresetResponse() : ActivateMarketplacePresetResponse(nullptr) {}
  ~ActivateMarketplacePresetResponse() override;
  explicit PROTOBUF_CONSTEXPR ActivateMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivateMarketplacePresetResponse(const ActivateMarketplacePresetResponse& from);
  ActivateMarketplacePresetResponse(ActivateMarketplacePresetResponse&& from) noexcept
    : ActivateMarketplacePresetResponse() {
    *this = ::std::move(from);
  }

  inline ActivateMarketplacePresetResponse& operator=(const ActivateMarketplacePresetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateMarketplacePresetResponse& operator=(ActivateMarketplacePresetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateMarketplacePresetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateMarketplacePresetResponse* internal_default_instance() {
    return reinterpret_cast<const ActivateMarketplacePresetResponse*>(
               &_ActivateMarketplacePresetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ActivateMarketplacePresetResponse& a, ActivateMarketplacePresetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateMarketplacePresetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateMarketplacePresetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateMarketplacePresetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivateMarketplacePresetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivateMarketplacePresetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivateMarketplacePresetResponse& from) {
    ActivateMarketplacePresetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateMarketplacePresetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "botcore.trading.v1.ActivateMarketplacePresetResponse";
  }
  protected:
  explicit ActivateMarketplacePresetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPresetFieldNumber = 1,
  };
  // .botcore.trading.v1.MarketplacePresetSummary preset = 1;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  const ::botcore::trading::v1::MarketplacePresetSummary& preset() const;
  PROTOBUF_NODISCARD ::botcore::trading::v1::MarketplacePresetSummary* release_preset();
  ::botcore::trading::v1::MarketplacePresetSummary* mutable_preset();
  void set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset);
  private:
  const ::botcore::trading::v1::MarketplacePresetSummary& _internal_preset() const;
  ::botcore::trading::v1::MarketplacePresetSummary* _internal_mutable_preset();
  public:
  void unsafe_arena_set_allocated_preset(
      ::botcore::trading::v1::MarketplacePresetSummary* preset);
  ::botcore::trading::v1::MarketplacePresetSummary* unsafe_arena_release_preset();

  // @@protoc_insertion_point(class_scope:botcore.trading.v1.ActivateMarketplacePresetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::botcore::trading::v1::MarketplacePresetSummary* preset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Instrument

// string exchange = 1;
inline void Instrument::clear_exchange() {
  _impl_.exchange_.ClearToEmpty();
}
inline const std::string& Instrument::exchange() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.Instrument.exchange)
  return _internal_exchange();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instrument::set_exchange(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.Instrument.exchange)
}
inline std::string* Instrument::mutable_exchange() {
  std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.Instrument.exchange)
  return _s;
}
inline const std::string& Instrument::_internal_exchange() const {
  return _impl_.exchange_.Get();
}
inline void Instrument::_internal_set_exchange(const std::string& value) {
  
  _impl_.exchange_.Set(value, GetArenaForAllocation());
}
inline std::string* Instrument::_internal_mutable_exchange() {
  
  return _impl_.exchange_.Mutable(GetArenaForAllocation());
}
inline std::string* Instrument::release_exchange() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.Instrument.exchange)
  return _impl_.exchange_.Release();
}
inline void Instrument::set_allocated_exchange(std::string* exchange) {
  if (exchange != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_.SetAllocated(exchange, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.Instrument.exchange)
}

// string symbol = 2;
inline void Instrument::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& Instrument::symbol() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.Instrument.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instrument::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.symbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.Instrument.symbol)
}
inline std::string* Instrument::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.Instrument.symbol)
  return _s;
}
inline const std::string& Instrument::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void Instrument::_internal_set_symbol(const std::string& value) {
  
  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* Instrument::_internal_mutable_symbol() {
  
  return _impl_.symbol_.Mutable(GetArenaForAllocation());
}
inline std::string* Instrument::release_symbol() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.Instrument.symbol)
  return _impl_.symbol_.Release();
}
inline void Instrument::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  _impl_.symbol_.SetAllocated(symbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.Instrument.symbol)
}

// string venue_symbol = 3;
inline void Instrument::clear_venue_symbol() {
  _impl_.venue_symbol_.ClearToEmpty();
}
inline const std::string& Instrument::venue_symbol() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.Instrument.venue_symbol)
  return _internal_venue_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instrument::set_venue_symbol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.venue_symbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.Instrument.venue_symbol)
}
inline std::string* Instrument::mutable_venue_symbol() {
  std::string* _s = _internal_mutable_venue_symbol();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.Instrument.venue_symbol)
  return _s;
}
inline const std::string& Instrument::_internal_venue_symbol() const {
  return _impl_.venue_symbol_.Get();
}
inline void Instrument::_internal_set_venue_symbol(const std::string& value) {
  
  _impl_.venue_symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* Instrument::_internal_mutable_venue_symbol() {
  
  return _impl_.venue_symbol_.Mutable(GetArenaForAllocation());
}
inline std::string* Instrument::release_venue_symbol() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.Instrument.venue_symbol)
  return _impl_.venue_symbol_.Release();
}
inline void Instrument::set_allocated_venue_symbol(std::string* venue_symbol) {
  if (venue_symbol != nullptr) {
    
  } else {
    
  }
  _impl_.venue_symbol_.SetAllocated(venue_symbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.venue_symbol_.IsDefault()) {
    _impl_.venue_symbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.Instrument.venue_symbol)
}

// string quote_currency = 4;
inline void Instrument::clear_quote_currency() {
  _impl_.quote_currency_.ClearToEmpty();
}
inline const std::string& Instrument::quote_currency() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.Instrument.quote_currency)
  return _internal_quote_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instrument::set_quote_currency(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quote_currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.Instrument.quote_currency)
}
inline std::string* Instrument::mutable_quote_currency() {
  std::string* _s = _internal_mutable_quote_currency();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.Instrument.quote_currency)
  return _s;
}
inline const std::string& Instrument::_internal_quote_currency() const {
  return _impl_.quote_currency_.Get();
}
inline void Instrument::_internal_set_quote_currency(const std::string& value) {
  
  _impl_.quote_currency_.Set(value, GetArenaForAllocation());
}
inline std::string* Instrument::_internal_mutable_quote_currency() {
  
  return _impl_.quote_currency_.Mutable(GetArenaForAllocation());
}
inline std::string* Instrument::release_quote_currency() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.Instrument.quote_currency)
  return _impl_.quote_currency_.Release();
}
inline void Instrument::set_allocated_quote_currency(std::string* quote_currency) {
  if (quote_currency != nullptr) {
    
  } else {
    
  }
  _impl_.quote_currency_.SetAllocated(quote_currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quote_currency_.IsDefault()) {
    _impl_.quote_currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.Instrument.quote_currency)
}

// string base_currency = 5;
inline void Instrument::clear_base_currency() {
  _impl_.base_currency_.ClearToEmpty();
}
inline const std::string& Instrument::base_currency() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.Instrument.base_currency)
  return _internal_base_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instrument::set_base_currency(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.Instrument.base_currency)
}
inline std::string* Instrument::mutable_base_currency() {
  std::string* _s = _internal_mutable_base_currency();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.Instrument.base_currency)
  return _s;
}
inline const std::string& Instrument::_internal_base_currency() const {
  return _impl_.base_currency_.Get();
}
inline void Instrument::_internal_set_base_currency(const std::string& value) {
  
  _impl_.base_currency_.Set(value, GetArenaForAllocation());
}
inline std::string* Instrument::_internal_mutable_base_currency() {
  
  return _impl_.base_currency_.Mutable(GetArenaForAllocation());
}
inline std::string* Instrument::release_base_currency() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.Instrument.base_currency)
  return _impl_.base_currency_.Release();
}
inline void Instrument::set_allocated_base_currency(std::string* base_currency) {
  if (base_currency != nullptr) {
    
  } else {
    
  }
  _impl_.base_currency_.SetAllocated(base_currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_currency_.IsDefault()) {
    _impl_.base_currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.Instrument.base_currency)
}

// -------------------------------------------------------------------

// CandleGranularity

// string iso8601_duration = 1;
inline void CandleGranularity::clear_iso8601_duration() {
  _impl_.iso8601_duration_.ClearToEmpty();
}
inline const std::string& CandleGranularity::iso8601_duration() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CandleGranularity.iso8601_duration)
  return _internal_iso8601_duration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CandleGranularity::set_iso8601_duration(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iso8601_duration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.CandleGranularity.iso8601_duration)
}
inline std::string* CandleGranularity::mutable_iso8601_duration() {
  std::string* _s = _internal_mutable_iso8601_duration();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.CandleGranularity.iso8601_duration)
  return _s;
}
inline const std::string& CandleGranularity::_internal_iso8601_duration() const {
  return _impl_.iso8601_duration_.Get();
}
inline void CandleGranularity::_internal_set_iso8601_duration(const std::string& value) {
  
  _impl_.iso8601_duration_.Set(value, GetArenaForAllocation());
}
inline std::string* CandleGranularity::_internal_mutable_iso8601_duration() {
  
  return _impl_.iso8601_duration_.Mutable(GetArenaForAllocation());
}
inline std::string* CandleGranularity::release_iso8601_duration() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.CandleGranularity.iso8601_duration)
  return _impl_.iso8601_duration_.Release();
}
inline void CandleGranularity::set_allocated_iso8601_duration(std::string* iso8601_duration) {
  if (iso8601_duration != nullptr) {
    
  } else {
    
  }
  _impl_.iso8601_duration_.SetAllocated(iso8601_duration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iso8601_duration_.IsDefault()) {
    _impl_.iso8601_duration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.CandleGranularity.iso8601_duration)
}

// -------------------------------------------------------------------

// OhlcvCandle

// .botcore.trading.v1.Instrument instrument = 1;
inline bool OhlcvCandle::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool OhlcvCandle::has_instrument() const {
  return _internal_has_instrument();
}
inline void OhlcvCandle::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& OhlcvCandle::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& OhlcvCandle::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.instrument)
  return _internal_instrument();
}
inline void OhlcvCandle::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.OhlcvCandle.instrument)
}
inline ::botcore::trading::v1::Instrument* OhlcvCandle::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* OhlcvCandle::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.OhlcvCandle.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* OhlcvCandle::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* OhlcvCandle::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.OhlcvCandle.instrument)
  return _msg;
}
inline void OhlcvCandle::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.OhlcvCandle.instrument)
}

// .google.protobuf.Timestamp open_time = 2;
inline bool OhlcvCandle::_internal_has_open_time() const {
  return this != internal_default_instance() && _impl_.open_time_ != nullptr;
}
inline bool OhlcvCandle::has_open_time() const {
  return _internal_has_open_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OhlcvCandle::_internal_open_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.open_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OhlcvCandle::open_time() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.open_time)
  return _internal_open_time();
}
inline void OhlcvCandle::unsafe_arena_set_allocated_open_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* open_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.open_time_);
  }
  _impl_.open_time_ = open_time;
  if (open_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.OhlcvCandle.open_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OhlcvCandle::release_open_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.open_time_;
  _impl_.open_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OhlcvCandle::unsafe_arena_release_open_time() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.OhlcvCandle.open_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.open_time_;
  _impl_.open_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OhlcvCandle::_internal_mutable_open_time() {
  
  if (_impl_.open_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.open_time_ = p;
  }
  return _impl_.open_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OhlcvCandle::mutable_open_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_open_time();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.OhlcvCandle.open_time)
  return _msg;
}
inline void OhlcvCandle::set_allocated_open_time(::PROTOBUF_NAMESPACE_ID::Timestamp* open_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.open_time_);
  }
  if (open_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(open_time));
    if (message_arena != submessage_arena) {
      open_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.open_time_ = open_time;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.OhlcvCandle.open_time)
}

// double open = 3;
inline void OhlcvCandle::clear_open() {
  _impl_.open_ = 0;
}
inline double OhlcvCandle::_internal_open() const {
  return _impl_.open_;
}
inline double OhlcvCandle::open() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.open)
  return _internal_open();
}
inline void OhlcvCandle::_internal_set_open(double value) {
  
  _impl_.open_ = value;
}
inline void OhlcvCandle::set_open(double value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.open)
}

// double high = 4;
inline void OhlcvCandle::clear_high() {
  _impl_.high_ = 0;
}
inline double OhlcvCandle::_internal_high() const {
  return _impl_.high_;
}
inline double OhlcvCandle::high() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.high)
  return _internal_high();
}
inline void OhlcvCandle::_internal_set_high(double value) {
  
  _impl_.high_ = value;
}
inline void OhlcvCandle::set_high(double value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.high)
}

// double low = 5;
inline void OhlcvCandle::clear_low() {
  _impl_.low_ = 0;
}
inline double OhlcvCandle::_internal_low() const {
  return _impl_.low_;
}
inline double OhlcvCandle::low() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.low)
  return _internal_low();
}
inline void OhlcvCandle::_internal_set_low(double value) {
  
  _impl_.low_ = value;
}
inline void OhlcvCandle::set_low(double value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.low)
}

// double close = 6;
inline void OhlcvCandle::clear_close() {
  _impl_.close_ = 0;
}
inline double OhlcvCandle::_internal_close() const {
  return _impl_.close_;
}
inline double OhlcvCandle::close() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.close)
  return _internal_close();
}
inline void OhlcvCandle::_internal_set_close(double value) {
  
  _impl_.close_ = value;
}
inline void OhlcvCandle::set_close(double value) {
  _internal_set_close(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.close)
}

// double volume = 7;
inline void OhlcvCandle::clear_volume() {
  _impl_.volume_ = 0;
}
inline double OhlcvCandle::_internal_volume() const {
  return _impl_.volume_;
}
inline double OhlcvCandle::volume() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.volume)
  return _internal_volume();
}
inline void OhlcvCandle::_internal_set_volume(double value) {
  
  _impl_.volume_ = value;
}
inline void OhlcvCandle::set_volume(double value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.volume)
}

// bool closed = 8;
inline void OhlcvCandle::clear_closed() {
  _impl_.closed_ = false;
}
inline bool OhlcvCandle::_internal_closed() const {
  return _impl_.closed_;
}
inline bool OhlcvCandle::closed() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.closed)
  return _internal_closed();
}
inline void OhlcvCandle::_internal_set_closed(bool value) {
  
  _impl_.closed_ = value;
}
inline void OhlcvCandle::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.closed)
}

// .botcore.trading.v1.CandleGranularity granularity = 9;
inline bool OhlcvCandle::_internal_has_granularity() const {
  return this != internal_default_instance() && _impl_.granularity_ != nullptr;
}
inline bool OhlcvCandle::has_granularity() const {
  return _internal_has_granularity();
}
inline void OhlcvCandle::clear_granularity() {
  if (GetArenaForAllocation() == nullptr && _impl_.granularity_ != nullptr) {
    delete _impl_.granularity_;
  }
  _impl_.granularity_ = nullptr;
}
inline const ::botcore::trading::v1::CandleGranularity& OhlcvCandle::_internal_granularity() const {
  const ::botcore::trading::v1::CandleGranularity* p = _impl_.granularity_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::CandleGranularity&>(
      ::botcore::trading::v1::_CandleGranularity_default_instance_);
}
inline const ::botcore::trading::v1::CandleGranularity& OhlcvCandle::granularity() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.granularity)
  return _internal_granularity();
}
inline void OhlcvCandle::unsafe_arena_set_allocated_granularity(
    ::botcore::trading::v1::CandleGranularity* granularity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.granularity_);
  }
  _impl_.granularity_ = granularity;
  if (granularity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.OhlcvCandle.granularity)
}
inline ::botcore::trading::v1::CandleGranularity* OhlcvCandle::release_granularity() {
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* OhlcvCandle::unsafe_arena_release_granularity() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.OhlcvCandle.granularity)
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* OhlcvCandle::_internal_mutable_granularity() {
  
  if (_impl_.granularity_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::CandleGranularity>(GetArenaForAllocation());
    _impl_.granularity_ = p;
  }
  return _impl_.granularity_;
}
inline ::botcore::trading::v1::CandleGranularity* OhlcvCandle::mutable_granularity() {
  ::botcore::trading::v1::CandleGranularity* _msg = _internal_mutable_granularity();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.OhlcvCandle.granularity)
  return _msg;
}
inline void OhlcvCandle::set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.granularity_;
  }
  if (granularity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(granularity);
    if (message_arena != submessage_arena) {
      granularity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, granularity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.granularity_ = granularity;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.OhlcvCandle.granularity)
}

// uint64 sequence = 10;
inline void OhlcvCandle::clear_sequence() {
  _impl_.sequence_ = uint64_t{0u};
}
inline uint64_t OhlcvCandle::_internal_sequence() const {
  return _impl_.sequence_;
}
inline uint64_t OhlcvCandle::sequence() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OhlcvCandle.sequence)
  return _internal_sequence();
}
inline void OhlcvCandle::_internal_set_sequence(uint64_t value) {
  
  _impl_.sequence_ = value;
}
inline void OhlcvCandle::set_sequence(uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OhlcvCandle.sequence)
}

// -------------------------------------------------------------------

// GetOhlcvHistoryRequest

// .botcore.trading.v1.Instrument instrument = 1;
inline bool GetOhlcvHistoryRequest::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool GetOhlcvHistoryRequest::has_instrument() const {
  return _internal_has_instrument();
}
inline void GetOhlcvHistoryRequest::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& GetOhlcvHistoryRequest::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& GetOhlcvHistoryRequest::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryRequest.instrument)
  return _internal_instrument();
}
inline void GetOhlcvHistoryRequest::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.instrument)
}
inline ::botcore::trading::v1::Instrument* GetOhlcvHistoryRequest::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* GetOhlcvHistoryRequest::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.GetOhlcvHistoryRequest.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* GetOhlcvHistoryRequest::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* GetOhlcvHistoryRequest::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryRequest.instrument)
  return _msg;
}
inline void GetOhlcvHistoryRequest::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.instrument)
}

// .botcore.trading.v1.CandleGranularity granularity = 2;
inline bool GetOhlcvHistoryRequest::_internal_has_granularity() const {
  return this != internal_default_instance() && _impl_.granularity_ != nullptr;
}
inline bool GetOhlcvHistoryRequest::has_granularity() const {
  return _internal_has_granularity();
}
inline void GetOhlcvHistoryRequest::clear_granularity() {
  if (GetArenaForAllocation() == nullptr && _impl_.granularity_ != nullptr) {
    delete _impl_.granularity_;
  }
  _impl_.granularity_ = nullptr;
}
inline const ::botcore::trading::v1::CandleGranularity& GetOhlcvHistoryRequest::_internal_granularity() const {
  const ::botcore::trading::v1::CandleGranularity* p = _impl_.granularity_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::CandleGranularity&>(
      ::botcore::trading::v1::_CandleGranularity_default_instance_);
}
inline const ::botcore::trading::v1::CandleGranularity& GetOhlcvHistoryRequest::granularity() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryRequest.granularity)
  return _internal_granularity();
}
inline void GetOhlcvHistoryRequest::unsafe_arena_set_allocated_granularity(
    ::botcore::trading::v1::CandleGranularity* granularity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.granularity_);
  }
  _impl_.granularity_ = granularity;
  if (granularity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.granularity)
}
inline ::botcore::trading::v1::CandleGranularity* GetOhlcvHistoryRequest::release_granularity() {
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* GetOhlcvHistoryRequest::unsafe_arena_release_granularity() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.GetOhlcvHistoryRequest.granularity)
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* GetOhlcvHistoryRequest::_internal_mutable_granularity() {
  
  if (_impl_.granularity_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::CandleGranularity>(GetArenaForAllocation());
    _impl_.granularity_ = p;
  }
  return _impl_.granularity_;
}
inline ::botcore::trading::v1::CandleGranularity* GetOhlcvHistoryRequest::mutable_granularity() {
  ::botcore::trading::v1::CandleGranularity* _msg = _internal_mutable_granularity();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryRequest.granularity)
  return _msg;
}
inline void GetOhlcvHistoryRequest::set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.granularity_;
  }
  if (granularity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(granularity);
    if (message_arena != submessage_arena) {
      granularity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, granularity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.granularity_ = granularity;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.granularity)
}

// .google.protobuf.Timestamp start_time = 3;
inline bool GetOhlcvHistoryRequest::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool GetOhlcvHistoryRequest::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryRequest::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryRequest::start_time() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryRequest.start_time)
  return _internal_start_time();
}
inline void GetOhlcvHistoryRequest::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.GetOhlcvHistoryRequest.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryRequest.start_time)
  return _msg;
}
inline void GetOhlcvHistoryRequest::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.start_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool GetOhlcvHistoryRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool GetOhlcvHistoryRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryRequest::end_time() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryRequest.end_time)
  return _internal_end_time();
}
inline void GetOhlcvHistoryRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.GetOhlcvHistoryRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryRequest.end_time)
  return _msg;
}
inline void GetOhlcvHistoryRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.GetOhlcvHistoryRequest.end_time)
}

// uint32 limit = 5;
inline void GetOhlcvHistoryRequest::clear_limit() {
  _impl_.limit_ = 0u;
}
inline uint32_t GetOhlcvHistoryRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline uint32_t GetOhlcvHistoryRequest::limit() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryRequest.limit)
  return _internal_limit();
}
inline void GetOhlcvHistoryRequest::_internal_set_limit(uint32_t value) {
  
  _impl_.limit_ = value;
}
inline void GetOhlcvHistoryRequest::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.GetOhlcvHistoryRequest.limit)
}

// -------------------------------------------------------------------

// GetOhlcvHistoryResponse

// repeated .botcore.trading.v1.OhlcvCandle candles = 1;
inline int GetOhlcvHistoryResponse::_internal_candles_size() const {
  return _impl_.candles_.size();
}
inline int GetOhlcvHistoryResponse::candles_size() const {
  return _internal_candles_size();
}
inline void GetOhlcvHistoryResponse::clear_candles() {
  _impl_.candles_.Clear();
}
inline ::botcore::trading::v1::OhlcvCandle* GetOhlcvHistoryResponse::mutable_candles(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryResponse.candles)
  return _impl_.candles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >*
GetOhlcvHistoryResponse::mutable_candles() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.GetOhlcvHistoryResponse.candles)
  return &_impl_.candles_;
}
inline const ::botcore::trading::v1::OhlcvCandle& GetOhlcvHistoryResponse::_internal_candles(int index) const {
  return _impl_.candles_.Get(index);
}
inline const ::botcore::trading::v1::OhlcvCandle& GetOhlcvHistoryResponse::candles(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryResponse.candles)
  return _internal_candles(index);
}
inline ::botcore::trading::v1::OhlcvCandle* GetOhlcvHistoryResponse::_internal_add_candles() {
  return _impl_.candles_.Add();
}
inline ::botcore::trading::v1::OhlcvCandle* GetOhlcvHistoryResponse::add_candles() {
  ::botcore::trading::v1::OhlcvCandle* _add = _internal_add_candles();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.GetOhlcvHistoryResponse.candles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >&
GetOhlcvHistoryResponse::candles() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.GetOhlcvHistoryResponse.candles)
  return _impl_.candles_;
}

// bool has_more = 2;
inline void GetOhlcvHistoryResponse::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool GetOhlcvHistoryResponse::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool GetOhlcvHistoryResponse::has_more() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryResponse.has_more)
  return _internal_has_more();
}
inline void GetOhlcvHistoryResponse::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void GetOhlcvHistoryResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.GetOhlcvHistoryResponse.has_more)
}

// .google.protobuf.Timestamp next_start_time = 3;
inline bool GetOhlcvHistoryResponse::_internal_has_next_start_time() const {
  return this != internal_default_instance() && _impl_.next_start_time_ != nullptr;
}
inline bool GetOhlcvHistoryResponse::has_next_start_time() const {
  return _internal_has_next_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryResponse::_internal_next_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetOhlcvHistoryResponse::next_start_time() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.GetOhlcvHistoryResponse.next_start_time)
  return _internal_next_start_time();
}
inline void GetOhlcvHistoryResponse::unsafe_arena_set_allocated_next_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_start_time_);
  }
  _impl_.next_start_time_ = next_start_time;
  if (next_start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.GetOhlcvHistoryResponse.next_start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryResponse::release_next_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_start_time_;
  _impl_.next_start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryResponse::unsafe_arena_release_next_start_time() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.GetOhlcvHistoryResponse.next_start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_start_time_;
  _impl_.next_start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryResponse::_internal_mutable_next_start_time() {
  
  if (_impl_.next_start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_start_time_ = p;
  }
  return _impl_.next_start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetOhlcvHistoryResponse::mutable_next_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_start_time();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.GetOhlcvHistoryResponse.next_start_time)
  return _msg;
}
inline void GetOhlcvHistoryResponse::set_allocated_next_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* next_start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_start_time_);
  }
  if (next_start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_start_time));
    if (message_arena != submessage_arena) {
      next_start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_start_time_ = next_start_time;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.GetOhlcvHistoryResponse.next_start_time)
}

// -------------------------------------------------------------------

// StreamOhlcvRequest

// .botcore.trading.v1.Instrument instrument = 1;
inline bool StreamOhlcvRequest::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool StreamOhlcvRequest::has_instrument() const {
  return _internal_has_instrument();
}
inline void StreamOhlcvRequest::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& StreamOhlcvRequest::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& StreamOhlcvRequest::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvRequest.instrument)
  return _internal_instrument();
}
inline void StreamOhlcvRequest::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.StreamOhlcvRequest.instrument)
}
inline ::botcore::trading::v1::Instrument* StreamOhlcvRequest::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* StreamOhlcvRequest::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.StreamOhlcvRequest.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* StreamOhlcvRequest::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* StreamOhlcvRequest::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvRequest.instrument)
  return _msg;
}
inline void StreamOhlcvRequest::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.StreamOhlcvRequest.instrument)
}

// .botcore.trading.v1.CandleGranularity granularity = 2;
inline bool StreamOhlcvRequest::_internal_has_granularity() const {
  return this != internal_default_instance() && _impl_.granularity_ != nullptr;
}
inline bool StreamOhlcvRequest::has_granularity() const {
  return _internal_has_granularity();
}
inline void StreamOhlcvRequest::clear_granularity() {
  if (GetArenaForAllocation() == nullptr && _impl_.granularity_ != nullptr) {
    delete _impl_.granularity_;
  }
  _impl_.granularity_ = nullptr;
}
inline const ::botcore::trading::v1::CandleGranularity& StreamOhlcvRequest::_internal_granularity() const {
  const ::botcore::trading::v1::CandleGranularity* p = _impl_.granularity_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::CandleGranularity&>(
      ::botcore::trading::v1::_CandleGranularity_default_instance_);
}
inline const ::botcore::trading::v1::CandleGranularity& StreamOhlcvRequest::granularity() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvRequest.granularity)
  return _internal_granularity();
}
inline void StreamOhlcvRequest::unsafe_arena_set_allocated_granularity(
    ::botcore::trading::v1::CandleGranularity* granularity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.granularity_);
  }
  _impl_.granularity_ = granularity;
  if (granularity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.StreamOhlcvRequest.granularity)
}
inline ::botcore::trading::v1::CandleGranularity* StreamOhlcvRequest::release_granularity() {
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* StreamOhlcvRequest::unsafe_arena_release_granularity() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.StreamOhlcvRequest.granularity)
  
  ::botcore::trading::v1::CandleGranularity* temp = _impl_.granularity_;
  _impl_.granularity_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::CandleGranularity* StreamOhlcvRequest::_internal_mutable_granularity() {
  
  if (_impl_.granularity_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::CandleGranularity>(GetArenaForAllocation());
    _impl_.granularity_ = p;
  }
  return _impl_.granularity_;
}
inline ::botcore::trading::v1::CandleGranularity* StreamOhlcvRequest::mutable_granularity() {
  ::botcore::trading::v1::CandleGranularity* _msg = _internal_mutable_granularity();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvRequest.granularity)
  return _msg;
}
inline void StreamOhlcvRequest::set_allocated_granularity(::botcore::trading::v1::CandleGranularity* granularity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.granularity_;
  }
  if (granularity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(granularity);
    if (message_arena != submessage_arena) {
      granularity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, granularity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.granularity_ = granularity;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.StreamOhlcvRequest.granularity)
}

// bool deliver_snapshots = 3;
inline void StreamOhlcvRequest::clear_deliver_snapshots() {
  _impl_.deliver_snapshots_ = false;
}
inline bool StreamOhlcvRequest::_internal_deliver_snapshots() const {
  return _impl_.deliver_snapshots_;
}
inline bool StreamOhlcvRequest::deliver_snapshots() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvRequest.deliver_snapshots)
  return _internal_deliver_snapshots();
}
inline void StreamOhlcvRequest::_internal_set_deliver_snapshots(bool value) {
  
  _impl_.deliver_snapshots_ = value;
}
inline void StreamOhlcvRequest::set_deliver_snapshots(bool value) {
  _internal_set_deliver_snapshots(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.StreamOhlcvRequest.deliver_snapshots)
}

// -------------------------------------------------------------------

// StreamOhlcvUpdate

// .botcore.trading.v1.StreamOhlcvSnapshot snapshot = 1;
inline bool StreamOhlcvUpdate::_internal_has_snapshot() const {
  return payload_case() == kSnapshot;
}
inline bool StreamOhlcvUpdate::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void StreamOhlcvUpdate::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void StreamOhlcvUpdate::clear_snapshot() {
  if (_internal_has_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.snapshot_;
    }
    clear_has_payload();
  }
}
inline ::botcore::trading::v1::StreamOhlcvSnapshot* StreamOhlcvUpdate::release_snapshot() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.StreamOhlcvUpdate.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_payload();
    ::botcore::trading::v1::StreamOhlcvSnapshot* temp = _impl_.payload_.snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::botcore::trading::v1::StreamOhlcvSnapshot& StreamOhlcvUpdate::_internal_snapshot() const {
  return _internal_has_snapshot()
      ? *_impl_.payload_.snapshot_
      : reinterpret_cast< ::botcore::trading::v1::StreamOhlcvSnapshot&>(::botcore::trading::v1::_StreamOhlcvSnapshot_default_instance_);
}
inline const ::botcore::trading::v1::StreamOhlcvSnapshot& StreamOhlcvUpdate::snapshot() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvUpdate.snapshot)
  return _internal_snapshot();
}
inline ::botcore::trading::v1::StreamOhlcvSnapshot* StreamOhlcvUpdate::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:botcore.trading.v1.StreamOhlcvUpdate.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_payload();
    ::botcore::trading::v1::StreamOhlcvSnapshot* temp = _impl_.payload_.snapshot_;
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamOhlcvUpdate::unsafe_arena_set_allocated_snapshot(::botcore::trading::v1::StreamOhlcvSnapshot* snapshot) {
  clear_payload();
  if (snapshot) {
    set_has_snapshot();
    _impl_.payload_.snapshot_ = snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.StreamOhlcvUpdate.snapshot)
}
inline ::botcore::trading::v1::StreamOhlcvSnapshot* StreamOhlcvUpdate::_internal_mutable_snapshot() {
  if (!_internal_has_snapshot()) {
    clear_payload();
    set_has_snapshot();
    _impl_.payload_.snapshot_ = CreateMaybeMessage< ::botcore::trading::v1::StreamOhlcvSnapshot >(GetArenaForAllocation());
  }
  return _impl_.payload_.snapshot_;
}
inline ::botcore::trading::v1::StreamOhlcvSnapshot* StreamOhlcvUpdate::mutable_snapshot() {
  ::botcore::trading::v1::StreamOhlcvSnapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvUpdate.snapshot)
  return _msg;
}

// .botcore.trading.v1.StreamOhlcvIncrement increment = 2;
inline bool StreamOhlcvUpdate::_internal_has_increment() const {
  return payload_case() == kIncrement;
}
inline bool StreamOhlcvUpdate::has_increment() const {
  return _internal_has_increment();
}
inline void StreamOhlcvUpdate::set_has_increment() {
  _impl_._oneof_case_[0] = kIncrement;
}
inline void StreamOhlcvUpdate::clear_increment() {
  if (_internal_has_increment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.increment_;
    }
    clear_has_payload();
  }
}
inline ::botcore::trading::v1::StreamOhlcvIncrement* StreamOhlcvUpdate::release_increment() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.StreamOhlcvUpdate.increment)
  if (_internal_has_increment()) {
    clear_has_payload();
    ::botcore::trading::v1::StreamOhlcvIncrement* temp = _impl_.payload_.increment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.increment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::botcore::trading::v1::StreamOhlcvIncrement& StreamOhlcvUpdate::_internal_increment() const {
  return _internal_has_increment()
      ? *_impl_.payload_.increment_
      : reinterpret_cast< ::botcore::trading::v1::StreamOhlcvIncrement&>(::botcore::trading::v1::_StreamOhlcvIncrement_default_instance_);
}
inline const ::botcore::trading::v1::StreamOhlcvIncrement& StreamOhlcvUpdate::increment() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvUpdate.increment)
  return _internal_increment();
}
inline ::botcore::trading::v1::StreamOhlcvIncrement* StreamOhlcvUpdate::unsafe_arena_release_increment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:botcore.trading.v1.StreamOhlcvUpdate.increment)
  if (_internal_has_increment()) {
    clear_has_payload();
    ::botcore::trading::v1::StreamOhlcvIncrement* temp = _impl_.payload_.increment_;
    _impl_.payload_.increment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamOhlcvUpdate::unsafe_arena_set_allocated_increment(::botcore::trading::v1::StreamOhlcvIncrement* increment) {
  clear_payload();
  if (increment) {
    set_has_increment();
    _impl_.payload_.increment_ = increment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.StreamOhlcvUpdate.increment)
}
inline ::botcore::trading::v1::StreamOhlcvIncrement* StreamOhlcvUpdate::_internal_mutable_increment() {
  if (!_internal_has_increment()) {
    clear_payload();
    set_has_increment();
    _impl_.payload_.increment_ = CreateMaybeMessage< ::botcore::trading::v1::StreamOhlcvIncrement >(GetArenaForAllocation());
  }
  return _impl_.payload_.increment_;
}
inline ::botcore::trading::v1::StreamOhlcvIncrement* StreamOhlcvUpdate::mutable_increment() {
  ::botcore::trading::v1::StreamOhlcvIncrement* _msg = _internal_mutable_increment();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvUpdate.increment)
  return _msg;
}

inline bool StreamOhlcvUpdate::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void StreamOhlcvUpdate::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline StreamOhlcvUpdate::PayloadCase StreamOhlcvUpdate::payload_case() const {
  return StreamOhlcvUpdate::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamOhlcvSnapshot

// repeated .botcore.trading.v1.OhlcvCandle candles = 1;
inline int StreamOhlcvSnapshot::_internal_candles_size() const {
  return _impl_.candles_.size();
}
inline int StreamOhlcvSnapshot::candles_size() const {
  return _internal_candles_size();
}
inline void StreamOhlcvSnapshot::clear_candles() {
  _impl_.candles_.Clear();
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvSnapshot::mutable_candles(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvSnapshot.candles)
  return _impl_.candles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >*
StreamOhlcvSnapshot::mutable_candles() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.StreamOhlcvSnapshot.candles)
  return &_impl_.candles_;
}
inline const ::botcore::trading::v1::OhlcvCandle& StreamOhlcvSnapshot::_internal_candles(int index) const {
  return _impl_.candles_.Get(index);
}
inline const ::botcore::trading::v1::OhlcvCandle& StreamOhlcvSnapshot::candles(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvSnapshot.candles)
  return _internal_candles(index);
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvSnapshot::_internal_add_candles() {
  return _impl_.candles_.Add();
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvSnapshot::add_candles() {
  ::botcore::trading::v1::OhlcvCandle* _add = _internal_add_candles();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.StreamOhlcvSnapshot.candles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OhlcvCandle >&
StreamOhlcvSnapshot::candles() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.StreamOhlcvSnapshot.candles)
  return _impl_.candles_;
}

// -------------------------------------------------------------------

// StreamOhlcvIncrement

// .botcore.trading.v1.OhlcvCandle candle = 1;
inline bool StreamOhlcvIncrement::_internal_has_candle() const {
  return this != internal_default_instance() && _impl_.candle_ != nullptr;
}
inline bool StreamOhlcvIncrement::has_candle() const {
  return _internal_has_candle();
}
inline void StreamOhlcvIncrement::clear_candle() {
  if (GetArenaForAllocation() == nullptr && _impl_.candle_ != nullptr) {
    delete _impl_.candle_;
  }
  _impl_.candle_ = nullptr;
}
inline const ::botcore::trading::v1::OhlcvCandle& StreamOhlcvIncrement::_internal_candle() const {
  const ::botcore::trading::v1::OhlcvCandle* p = _impl_.candle_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::OhlcvCandle&>(
      ::botcore::trading::v1::_OhlcvCandle_default_instance_);
}
inline const ::botcore::trading::v1::OhlcvCandle& StreamOhlcvIncrement::candle() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.StreamOhlcvIncrement.candle)
  return _internal_candle();
}
inline void StreamOhlcvIncrement::unsafe_arena_set_allocated_candle(
    ::botcore::trading::v1::OhlcvCandle* candle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.candle_);
  }
  _impl_.candle_ = candle;
  if (candle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.StreamOhlcvIncrement.candle)
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvIncrement::release_candle() {
  
  ::botcore::trading::v1::OhlcvCandle* temp = _impl_.candle_;
  _impl_.candle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvIncrement::unsafe_arena_release_candle() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.StreamOhlcvIncrement.candle)
  
  ::botcore::trading::v1::OhlcvCandle* temp = _impl_.candle_;
  _impl_.candle_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvIncrement::_internal_mutable_candle() {
  
  if (_impl_.candle_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::OhlcvCandle>(GetArenaForAllocation());
    _impl_.candle_ = p;
  }
  return _impl_.candle_;
}
inline ::botcore::trading::v1::OhlcvCandle* StreamOhlcvIncrement::mutable_candle() {
  ::botcore::trading::v1::OhlcvCandle* _msg = _internal_mutable_candle();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.StreamOhlcvIncrement.candle)
  return _msg;
}
inline void StreamOhlcvIncrement::set_allocated_candle(::botcore::trading::v1::OhlcvCandle* candle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.candle_;
  }
  if (candle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(candle);
    if (message_arena != submessage_arena) {
      candle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.candle_ = candle;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.StreamOhlcvIncrement.candle)
}

// -------------------------------------------------------------------

// ListTradableInstrumentsRequest

// string exchange = 1;
inline void ListTradableInstrumentsRequest::clear_exchange() {
  _impl_.exchange_.ClearToEmpty();
}
inline const std::string& ListTradableInstrumentsRequest::exchange() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ListTradableInstrumentsRequest.exchange)
  return _internal_exchange();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTradableInstrumentsRequest::set_exchange(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ListTradableInstrumentsRequest.exchange)
}
inline std::string* ListTradableInstrumentsRequest::mutable_exchange() {
  std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ListTradableInstrumentsRequest.exchange)
  return _s;
}
inline const std::string& ListTradableInstrumentsRequest::_internal_exchange() const {
  return _impl_.exchange_.Get();
}
inline void ListTradableInstrumentsRequest::_internal_set_exchange(const std::string& value) {
  
  _impl_.exchange_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTradableInstrumentsRequest::_internal_mutable_exchange() {
  
  return _impl_.exchange_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTradableInstrumentsRequest::release_exchange() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ListTradableInstrumentsRequest.exchange)
  return _impl_.exchange_.Release();
}
inline void ListTradableInstrumentsRequest::set_allocated_exchange(std::string* exchange) {
  if (exchange != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_.SetAllocated(exchange, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ListTradableInstrumentsRequest.exchange)
}

// -------------------------------------------------------------------

// TradableInstrumentMetadata

// .botcore.trading.v1.Instrument instrument = 1;
inline bool TradableInstrumentMetadata::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool TradableInstrumentMetadata::has_instrument() const {
  return _internal_has_instrument();
}
inline void TradableInstrumentMetadata::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& TradableInstrumentMetadata::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& TradableInstrumentMetadata::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.instrument)
  return _internal_instrument();
}
inline void TradableInstrumentMetadata::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.TradableInstrumentMetadata.instrument)
}
inline ::botcore::trading::v1::Instrument* TradableInstrumentMetadata::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* TradableInstrumentMetadata::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.TradableInstrumentMetadata.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* TradableInstrumentMetadata::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* TradableInstrumentMetadata::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.TradableInstrumentMetadata.instrument)
  return _msg;
}
inline void TradableInstrumentMetadata::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.TradableInstrumentMetadata.instrument)
}

// double price_step = 2;
inline void TradableInstrumentMetadata::clear_price_step() {
  _impl_.price_step_ = 0;
}
inline double TradableInstrumentMetadata::_internal_price_step() const {
  return _impl_.price_step_;
}
inline double TradableInstrumentMetadata::price_step() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.price_step)
  return _internal_price_step();
}
inline void TradableInstrumentMetadata::_internal_set_price_step(double value) {
  
  _impl_.price_step_ = value;
}
inline void TradableInstrumentMetadata::set_price_step(double value) {
  _internal_set_price_step(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.price_step)
}

// double amount_step = 3;
inline void TradableInstrumentMetadata::clear_amount_step() {
  _impl_.amount_step_ = 0;
}
inline double TradableInstrumentMetadata::_internal_amount_step() const {
  return _impl_.amount_step_;
}
inline double TradableInstrumentMetadata::amount_step() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.amount_step)
  return _internal_amount_step();
}
inline void TradableInstrumentMetadata::_internal_set_amount_step(double value) {
  
  _impl_.amount_step_ = value;
}
inline void TradableInstrumentMetadata::set_amount_step(double value) {
  _internal_set_amount_step(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.amount_step)
}

// double min_notional = 4;
inline void TradableInstrumentMetadata::clear_min_notional() {
  _impl_.min_notional_ = 0;
}
inline double TradableInstrumentMetadata::_internal_min_notional() const {
  return _impl_.min_notional_;
}
inline double TradableInstrumentMetadata::min_notional() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.min_notional)
  return _internal_min_notional();
}
inline void TradableInstrumentMetadata::_internal_set_min_notional(double value) {
  
  _impl_.min_notional_ = value;
}
inline void TradableInstrumentMetadata::set_min_notional(double value) {
  _internal_set_min_notional(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.min_notional)
}

// double min_amount = 5;
inline void TradableInstrumentMetadata::clear_min_amount() {
  _impl_.min_amount_ = 0;
}
inline double TradableInstrumentMetadata::_internal_min_amount() const {
  return _impl_.min_amount_;
}
inline double TradableInstrumentMetadata::min_amount() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.min_amount)
  return _internal_min_amount();
}
inline void TradableInstrumentMetadata::_internal_set_min_amount(double value) {
  
  _impl_.min_amount_ = value;
}
inline void TradableInstrumentMetadata::set_min_amount(double value) {
  _internal_set_min_amount(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.min_amount)
}

// double max_amount = 6;
inline void TradableInstrumentMetadata::clear_max_amount() {
  _impl_.max_amount_ = 0;
}
inline double TradableInstrumentMetadata::_internal_max_amount() const {
  return _impl_.max_amount_;
}
inline double TradableInstrumentMetadata::max_amount() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.max_amount)
  return _internal_max_amount();
}
inline void TradableInstrumentMetadata::_internal_set_max_amount(double value) {
  
  _impl_.max_amount_ = value;
}
inline void TradableInstrumentMetadata::set_max_amount(double value) {
  _internal_set_max_amount(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.max_amount)
}

// double min_price = 7;
inline void TradableInstrumentMetadata::clear_min_price() {
  _impl_.min_price_ = 0;
}
inline double TradableInstrumentMetadata::_internal_min_price() const {
  return _impl_.min_price_;
}
inline double TradableInstrumentMetadata::min_price() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.min_price)
  return _internal_min_price();
}
inline void TradableInstrumentMetadata::_internal_set_min_price(double value) {
  
  _impl_.min_price_ = value;
}
inline void TradableInstrumentMetadata::set_min_price(double value) {
  _internal_set_min_price(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.min_price)
}

// double max_price = 8;
inline void TradableInstrumentMetadata::clear_max_price() {
  _impl_.max_price_ = 0;
}
inline double TradableInstrumentMetadata::_internal_max_price() const {
  return _impl_.max_price_;
}
inline double TradableInstrumentMetadata::max_price() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.TradableInstrumentMetadata.max_price)
  return _internal_max_price();
}
inline void TradableInstrumentMetadata::_internal_set_max_price(double value) {
  
  _impl_.max_price_ = value;
}
inline void TradableInstrumentMetadata::set_max_price(double value) {
  _internal_set_max_price(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.TradableInstrumentMetadata.max_price)
}

// -------------------------------------------------------------------

// ListTradableInstrumentsResponse

// repeated .botcore.trading.v1.TradableInstrumentMetadata instruments = 1;
inline int ListTradableInstrumentsResponse::_internal_instruments_size() const {
  return _impl_.instruments_.size();
}
inline int ListTradableInstrumentsResponse::instruments_size() const {
  return _internal_instruments_size();
}
inline void ListTradableInstrumentsResponse::clear_instruments() {
  _impl_.instruments_.Clear();
}
inline ::botcore::trading::v1::TradableInstrumentMetadata* ListTradableInstrumentsResponse::mutable_instruments(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ListTradableInstrumentsResponse.instruments)
  return _impl_.instruments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::TradableInstrumentMetadata >*
ListTradableInstrumentsResponse::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.ListTradableInstrumentsResponse.instruments)
  return &_impl_.instruments_;
}
inline const ::botcore::trading::v1::TradableInstrumentMetadata& ListTradableInstrumentsResponse::_internal_instruments(int index) const {
  return _impl_.instruments_.Get(index);
}
inline const ::botcore::trading::v1::TradableInstrumentMetadata& ListTradableInstrumentsResponse::instruments(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ListTradableInstrumentsResponse.instruments)
  return _internal_instruments(index);
}
inline ::botcore::trading::v1::TradableInstrumentMetadata* ListTradableInstrumentsResponse::_internal_add_instruments() {
  return _impl_.instruments_.Add();
}
inline ::botcore::trading::v1::TradableInstrumentMetadata* ListTradableInstrumentsResponse::add_instruments() {
  ::botcore::trading::v1::TradableInstrumentMetadata* _add = _internal_add_instruments();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.ListTradableInstrumentsResponse.instruments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::TradableInstrumentMetadata >&
ListTradableInstrumentsResponse::instruments() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.ListTradableInstrumentsResponse.instruments)
  return _impl_.instruments_;
}

// -------------------------------------------------------------------

// SubmitOrderRequest

// .botcore.trading.v1.Instrument instrument = 1;
inline bool SubmitOrderRequest::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool SubmitOrderRequest::has_instrument() const {
  return _internal_has_instrument();
}
inline void SubmitOrderRequest::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& SubmitOrderRequest::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& SubmitOrderRequest::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.instrument)
  return _internal_instrument();
}
inline void SubmitOrderRequest::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.SubmitOrderRequest.instrument)
}
inline ::botcore::trading::v1::Instrument* SubmitOrderRequest::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* SubmitOrderRequest::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.SubmitOrderRequest.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* SubmitOrderRequest::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* SubmitOrderRequest::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderRequest.instrument)
  return _msg;
}
inline void SubmitOrderRequest::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.SubmitOrderRequest.instrument)
}

// .botcore.trading.v1.OrderSide side = 2;
inline void SubmitOrderRequest::clear_side() {
  _impl_.side_ = 0;
}
inline ::botcore::trading::v1::OrderSide SubmitOrderRequest::_internal_side() const {
  return static_cast< ::botcore::trading::v1::OrderSide >(_impl_.side_);
}
inline ::botcore::trading::v1::OrderSide SubmitOrderRequest::side() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.side)
  return _internal_side();
}
inline void SubmitOrderRequest::_internal_set_side(::botcore::trading::v1::OrderSide value) {
  
  _impl_.side_ = value;
}
inline void SubmitOrderRequest::set_side(::botcore::trading::v1::OrderSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.side)
}

// .botcore.trading.v1.OrderType type = 3;
inline void SubmitOrderRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::botcore::trading::v1::OrderType SubmitOrderRequest::_internal_type() const {
  return static_cast< ::botcore::trading::v1::OrderType >(_impl_.type_);
}
inline ::botcore::trading::v1::OrderType SubmitOrderRequest::type() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.type)
  return _internal_type();
}
inline void SubmitOrderRequest::_internal_set_type(::botcore::trading::v1::OrderType value) {
  
  _impl_.type_ = value;
}
inline void SubmitOrderRequest::set_type(::botcore::trading::v1::OrderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.type)
}

// double quantity = 4;
inline void SubmitOrderRequest::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline double SubmitOrderRequest::_internal_quantity() const {
  return _impl_.quantity_;
}
inline double SubmitOrderRequest::quantity() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.quantity)
  return _internal_quantity();
}
inline void SubmitOrderRequest::_internal_set_quantity(double value) {
  
  _impl_.quantity_ = value;
}
inline void SubmitOrderRequest::set_quantity(double value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.quantity)
}

// double price = 5;
inline void SubmitOrderRequest::clear_price() {
  _impl_.price_ = 0;
}
inline double SubmitOrderRequest::_internal_price() const {
  return _impl_.price_;
}
inline double SubmitOrderRequest::price() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.price)
  return _internal_price();
}
inline void SubmitOrderRequest::_internal_set_price(double value) {
  
  _impl_.price_ = value;
}
inline void SubmitOrderRequest::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.price)
}

// .botcore.trading.v1.TimeInForce time_in_force = 6;
inline void SubmitOrderRequest::clear_time_in_force() {
  _impl_.time_in_force_ = 0;
}
inline ::botcore::trading::v1::TimeInForce SubmitOrderRequest::_internal_time_in_force() const {
  return static_cast< ::botcore::trading::v1::TimeInForce >(_impl_.time_in_force_);
}
inline ::botcore::trading::v1::TimeInForce SubmitOrderRequest::time_in_force() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.time_in_force)
  return _internal_time_in_force();
}
inline void SubmitOrderRequest::_internal_set_time_in_force(::botcore::trading::v1::TimeInForce value) {
  
  _impl_.time_in_force_ = value;
}
inline void SubmitOrderRequest::set_time_in_force(::botcore::trading::v1::TimeInForce value) {
  _internal_set_time_in_force(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.time_in_force)
}

// string client_order_id = 7;
inline void SubmitOrderRequest::clear_client_order_id() {
  _impl_.client_order_id_.ClearToEmpty();
}
inline const std::string& SubmitOrderRequest::client_order_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.client_order_id)
  return _internal_client_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitOrderRequest::set_client_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.client_order_id)
}
inline std::string* SubmitOrderRequest::mutable_client_order_id() {
  std::string* _s = _internal_mutable_client_order_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderRequest.client_order_id)
  return _s;
}
inline const std::string& SubmitOrderRequest::_internal_client_order_id() const {
  return _impl_.client_order_id_.Get();
}
inline void SubmitOrderRequest::_internal_set_client_order_id(const std::string& value) {
  
  _impl_.client_order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitOrderRequest::_internal_mutable_client_order_id() {
  
  return _impl_.client_order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitOrderRequest::release_client_order_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.SubmitOrderRequest.client_order_id)
  return _impl_.client_order_id_.Release();
}
inline void SubmitOrderRequest::set_allocated_client_order_id(std::string* client_order_id) {
  if (client_order_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_order_id_.SetAllocated(client_order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_order_id_.IsDefault()) {
    _impl_.client_order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.SubmitOrderRequest.client_order_id)
}

// double max_slippage_bps = 8;
inline void SubmitOrderRequest::clear_max_slippage_bps() {
  _impl_.max_slippage_bps_ = 0;
}
inline double SubmitOrderRequest::_internal_max_slippage_bps() const {
  return _impl_.max_slippage_bps_;
}
inline double SubmitOrderRequest::max_slippage_bps() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.max_slippage_bps)
  return _internal_max_slippage_bps();
}
inline void SubmitOrderRequest::_internal_set_max_slippage_bps(double value) {
  
  _impl_.max_slippage_bps_ = value;
}
inline void SubmitOrderRequest::set_max_slippage_bps(double value) {
  _internal_set_max_slippage_bps(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderRequest.max_slippage_bps)
}

// .google.protobuf.Timestamp expiry_time = 9;
inline bool SubmitOrderRequest::_internal_has_expiry_time() const {
  return this != internal_default_instance() && _impl_.expiry_time_ != nullptr;
}
inline bool SubmitOrderRequest::has_expiry_time() const {
  return _internal_has_expiry_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubmitOrderRequest::_internal_expiry_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expiry_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubmitOrderRequest::expiry_time() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderRequest.expiry_time)
  return _internal_expiry_time();
}
inline void SubmitOrderRequest::unsafe_arena_set_allocated_expiry_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_time_);
  }
  _impl_.expiry_time_ = expiry_time;
  if (expiry_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.SubmitOrderRequest.expiry_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubmitOrderRequest::release_expiry_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubmitOrderRequest::unsafe_arena_release_expiry_time() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.SubmitOrderRequest.expiry_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubmitOrderRequest::_internal_mutable_expiry_time() {
  
  if (_impl_.expiry_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expiry_time_ = p;
  }
  return _impl_.expiry_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubmitOrderRequest::mutable_expiry_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expiry_time();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderRequest.expiry_time)
  return _msg;
}
inline void SubmitOrderRequest::set_allocated_expiry_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_time_);
  }
  if (expiry_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_time));
    if (message_arena != submessage_arena) {
      expiry_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expiry_time_ = expiry_time;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.SubmitOrderRequest.expiry_time)
}

// -------------------------------------------------------------------

// SubmitOrderResponse

// string order_id = 1;
inline void SubmitOrderResponse::clear_order_id() {
  _impl_.order_id_.ClearToEmpty();
}
inline const std::string& SubmitOrderResponse::order_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderResponse.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitOrderResponse::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderResponse.order_id)
}
inline std::string* SubmitOrderResponse::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderResponse.order_id)
  return _s;
}
inline const std::string& SubmitOrderResponse::_internal_order_id() const {
  return _impl_.order_id_.Get();
}
inline void SubmitOrderResponse::_internal_set_order_id(const std::string& value) {
  
  _impl_.order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitOrderResponse::_internal_mutable_order_id() {
  
  return _impl_.order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitOrderResponse::release_order_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.SubmitOrderResponse.order_id)
  return _impl_.order_id_.Release();
}
inline void SubmitOrderResponse::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  _impl_.order_id_.SetAllocated(order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.SubmitOrderResponse.order_id)
}

// string external_order_id = 2;
inline void SubmitOrderResponse::clear_external_order_id() {
  _impl_.external_order_id_.ClearToEmpty();
}
inline const std::string& SubmitOrderResponse::external_order_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderResponse.external_order_id)
  return _internal_external_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitOrderResponse::set_external_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.external_order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderResponse.external_order_id)
}
inline std::string* SubmitOrderResponse::mutable_external_order_id() {
  std::string* _s = _internal_mutable_external_order_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderResponse.external_order_id)
  return _s;
}
inline const std::string& SubmitOrderResponse::_internal_external_order_id() const {
  return _impl_.external_order_id_.Get();
}
inline void SubmitOrderResponse::_internal_set_external_order_id(const std::string& value) {
  
  _impl_.external_order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitOrderResponse::_internal_mutable_external_order_id() {
  
  return _impl_.external_order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitOrderResponse::release_external_order_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.SubmitOrderResponse.external_order_id)
  return _impl_.external_order_id_.Release();
}
inline void SubmitOrderResponse::set_allocated_external_order_id(std::string* external_order_id) {
  if (external_order_id != nullptr) {
    
  } else {
    
  }
  _impl_.external_order_id_.SetAllocated(external_order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_order_id_.IsDefault()) {
    _impl_.external_order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.SubmitOrderResponse.external_order_id)
}

// .botcore.trading.v1.OrderStatus status = 3;
inline void SubmitOrderResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::botcore::trading::v1::OrderStatus SubmitOrderResponse::_internal_status() const {
  return static_cast< ::botcore::trading::v1::OrderStatus >(_impl_.status_);
}
inline ::botcore::trading::v1::OrderStatus SubmitOrderResponse::status() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderResponse.status)
  return _internal_status();
}
inline void SubmitOrderResponse::_internal_set_status(::botcore::trading::v1::OrderStatus value) {
  
  _impl_.status_ = value;
}
inline void SubmitOrderResponse::set_status(::botcore::trading::v1::OrderStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.SubmitOrderResponse.status)
}

// repeated .botcore.trading.v1.OrderConstraintViolation violations = 4;
inline int SubmitOrderResponse::_internal_violations_size() const {
  return _impl_.violations_.size();
}
inline int SubmitOrderResponse::violations_size() const {
  return _internal_violations_size();
}
inline void SubmitOrderResponse::clear_violations() {
  _impl_.violations_.Clear();
}
inline ::botcore::trading::v1::OrderConstraintViolation* SubmitOrderResponse::mutable_violations(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.SubmitOrderResponse.violations)
  return _impl_.violations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OrderConstraintViolation >*
SubmitOrderResponse::mutable_violations() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.SubmitOrderResponse.violations)
  return &_impl_.violations_;
}
inline const ::botcore::trading::v1::OrderConstraintViolation& SubmitOrderResponse::_internal_violations(int index) const {
  return _impl_.violations_.Get(index);
}
inline const ::botcore::trading::v1::OrderConstraintViolation& SubmitOrderResponse::violations(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.SubmitOrderResponse.violations)
  return _internal_violations(index);
}
inline ::botcore::trading::v1::OrderConstraintViolation* SubmitOrderResponse::_internal_add_violations() {
  return _impl_.violations_.Add();
}
inline ::botcore::trading::v1::OrderConstraintViolation* SubmitOrderResponse::add_violations() {
  ::botcore::trading::v1::OrderConstraintViolation* _add = _internal_add_violations();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.SubmitOrderResponse.violations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::OrderConstraintViolation >&
SubmitOrderResponse::violations() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.SubmitOrderResponse.violations)
  return _impl_.violations_;
}

// -------------------------------------------------------------------

// OrderConstraintViolation

// string code = 1;
inline void OrderConstraintViolation::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& OrderConstraintViolation::code() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OrderConstraintViolation.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConstraintViolation::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OrderConstraintViolation.code)
}
inline std::string* OrderConstraintViolation::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.OrderConstraintViolation.code)
  return _s;
}
inline const std::string& OrderConstraintViolation::_internal_code() const {
  return _impl_.code_.Get();
}
inline void OrderConstraintViolation::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConstraintViolation::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConstraintViolation::release_code() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.OrderConstraintViolation.code)
  return _impl_.code_.Release();
}
inline void OrderConstraintViolation::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.OrderConstraintViolation.code)
}

// string message = 2;
inline void OrderConstraintViolation::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& OrderConstraintViolation::message() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.OrderConstraintViolation.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConstraintViolation::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.OrderConstraintViolation.message)
}
inline std::string* OrderConstraintViolation::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.OrderConstraintViolation.message)
  return _s;
}
inline const std::string& OrderConstraintViolation::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OrderConstraintViolation::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConstraintViolation::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConstraintViolation::release_message() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.OrderConstraintViolation.message)
  return _impl_.message_.Release();
}
inline void OrderConstraintViolation::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.OrderConstraintViolation.message)
}

// -------------------------------------------------------------------

// CancelOrderRequest

// .botcore.trading.v1.Instrument instrument = 1;
inline bool CancelOrderRequest::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool CancelOrderRequest::has_instrument() const {
  return _internal_has_instrument();
}
inline void CancelOrderRequest::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& CancelOrderRequest::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& CancelOrderRequest::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CancelOrderRequest.instrument)
  return _internal_instrument();
}
inline void CancelOrderRequest::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.CancelOrderRequest.instrument)
}
inline ::botcore::trading::v1::Instrument* CancelOrderRequest::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* CancelOrderRequest::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.CancelOrderRequest.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* CancelOrderRequest::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* CancelOrderRequest::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.CancelOrderRequest.instrument)
  return _msg;
}
inline void CancelOrderRequest::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.CancelOrderRequest.instrument)
}

// string order_id = 2;
inline void CancelOrderRequest::clear_order_id() {
  _impl_.order_id_.ClearToEmpty();
}
inline const std::string& CancelOrderRequest::order_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CancelOrderRequest.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrderRequest::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.CancelOrderRequest.order_id)
}
inline std::string* CancelOrderRequest::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.CancelOrderRequest.order_id)
  return _s;
}
inline const std::string& CancelOrderRequest::_internal_order_id() const {
  return _impl_.order_id_.Get();
}
inline void CancelOrderRequest::_internal_set_order_id(const std::string& value) {
  
  _impl_.order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelOrderRequest::_internal_mutable_order_id() {
  
  return _impl_.order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelOrderRequest::release_order_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.CancelOrderRequest.order_id)
  return _impl_.order_id_.Release();
}
inline void CancelOrderRequest::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  _impl_.order_id_.SetAllocated(order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.CancelOrderRequest.order_id)
}

// string client_order_id = 3;
inline void CancelOrderRequest::clear_client_order_id() {
  _impl_.client_order_id_.ClearToEmpty();
}
inline const std::string& CancelOrderRequest::client_order_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CancelOrderRequest.client_order_id)
  return _internal_client_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrderRequest::set_client_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.CancelOrderRequest.client_order_id)
}
inline std::string* CancelOrderRequest::mutable_client_order_id() {
  std::string* _s = _internal_mutable_client_order_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.CancelOrderRequest.client_order_id)
  return _s;
}
inline const std::string& CancelOrderRequest::_internal_client_order_id() const {
  return _impl_.client_order_id_.Get();
}
inline void CancelOrderRequest::_internal_set_client_order_id(const std::string& value) {
  
  _impl_.client_order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelOrderRequest::_internal_mutable_client_order_id() {
  
  return _impl_.client_order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelOrderRequest::release_client_order_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.CancelOrderRequest.client_order_id)
  return _impl_.client_order_id_.Release();
}
inline void CancelOrderRequest::set_allocated_client_order_id(std::string* client_order_id) {
  if (client_order_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_order_id_.SetAllocated(client_order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_order_id_.IsDefault()) {
    _impl_.client_order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.CancelOrderRequest.client_order_id)
}

// -------------------------------------------------------------------

// CancelOrderResponse

// .botcore.trading.v1.OrderStatus status = 1;
inline void CancelOrderResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::botcore::trading::v1::OrderStatus CancelOrderResponse::_internal_status() const {
  return static_cast< ::botcore::trading::v1::OrderStatus >(_impl_.status_);
}
inline ::botcore::trading::v1::OrderStatus CancelOrderResponse::status() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CancelOrderResponse.status)
  return _internal_status();
}
inline void CancelOrderResponse::_internal_set_status(::botcore::trading::v1::OrderStatus value) {
  
  _impl_.status_ = value;
}
inline void CancelOrderResponse::set_status(::botcore::trading::v1::OrderStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.CancelOrderResponse.status)
}

// string message = 2;
inline void CancelOrderResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CancelOrderResponse::message() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.CancelOrderResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrderResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.CancelOrderResponse.message)
}
inline std::string* CancelOrderResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.CancelOrderResponse.message)
  return _s;
}
inline const std::string& CancelOrderResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CancelOrderResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelOrderResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelOrderResponse::release_message() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.CancelOrderResponse.message)
  return _impl_.message_.Release();
}
inline void CancelOrderResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.CancelOrderResponse.message)
}

// -------------------------------------------------------------------

// RiskStateRequest

// .botcore.trading.v1.Instrument instrument = 1;
inline bool RiskStateRequest::_internal_has_instrument() const {
  return this != internal_default_instance() && _impl_.instrument_ != nullptr;
}
inline bool RiskStateRequest::has_instrument() const {
  return _internal_has_instrument();
}
inline void RiskStateRequest::clear_instrument() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_ != nullptr) {
    delete _impl_.instrument_;
  }
  _impl_.instrument_ = nullptr;
}
inline const ::botcore::trading::v1::Instrument& RiskStateRequest::_internal_instrument() const {
  const ::botcore::trading::v1::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::Instrument&>(
      ::botcore::trading::v1::_Instrument_default_instance_);
}
inline const ::botcore::trading::v1::Instrument& RiskStateRequest::instrument() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskStateRequest.instrument)
  return _internal_instrument();
}
inline void RiskStateRequest::unsafe_arena_set_allocated_instrument(
    ::botcore::trading::v1::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.RiskStateRequest.instrument)
}
inline ::botcore::trading::v1::Instrument* RiskStateRequest::release_instrument() {
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::Instrument* RiskStateRequest::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.RiskStateRequest.instrument)
  
  ::botcore::trading::v1::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::Instrument* RiskStateRequest::_internal_mutable_instrument() {
  
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::botcore::trading::v1::Instrument* RiskStateRequest::mutable_instrument() {
  ::botcore::trading::v1::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.RiskStateRequest.instrument)
  return _msg;
}
inline void RiskStateRequest::set_allocated_instrument(::botcore::trading::v1::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.RiskStateRequest.instrument)
}

// -------------------------------------------------------------------

// ExposureLimit

// string code = 1;
inline void ExposureLimit::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& ExposureLimit::code() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExposureLimit.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExposureLimit::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExposureLimit.code)
}
inline std::string* ExposureLimit::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExposureLimit.code)
  return _s;
}
inline const std::string& ExposureLimit::_internal_code() const {
  return _impl_.code_.Get();
}
inline void ExposureLimit::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* ExposureLimit::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* ExposureLimit::release_code() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExposureLimit.code)
  return _impl_.code_.Release();
}
inline void ExposureLimit::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExposureLimit.code)
}

// double max_value = 2;
inline void ExposureLimit::clear_max_value() {
  _impl_.max_value_ = 0;
}
inline double ExposureLimit::_internal_max_value() const {
  return _impl_.max_value_;
}
inline double ExposureLimit::max_value() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExposureLimit.max_value)
  return _internal_max_value();
}
inline void ExposureLimit::_internal_set_max_value(double value) {
  
  _impl_.max_value_ = value;
}
inline void ExposureLimit::set_max_value(double value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExposureLimit.max_value)
}

// double current_value = 3;
inline void ExposureLimit::clear_current_value() {
  _impl_.current_value_ = 0;
}
inline double ExposureLimit::_internal_current_value() const {
  return _impl_.current_value_;
}
inline double ExposureLimit::current_value() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExposureLimit.current_value)
  return _internal_current_value();
}
inline void ExposureLimit::_internal_set_current_value(double value) {
  
  _impl_.current_value_ = value;
}
inline void ExposureLimit::set_current_value(double value) {
  _internal_set_current_value(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExposureLimit.current_value)
}

// double threshold_value = 4;
inline void ExposureLimit::clear_threshold_value() {
  _impl_.threshold_value_ = 0;
}
inline double ExposureLimit::_internal_threshold_value() const {
  return _impl_.threshold_value_;
}
inline double ExposureLimit::threshold_value() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExposureLimit.threshold_value)
  return _internal_threshold_value();
}
inline void ExposureLimit::_internal_set_threshold_value(double value) {
  
  _impl_.threshold_value_ = value;
}
inline void ExposureLimit::set_threshold_value(double value) {
  _internal_set_threshold_value(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExposureLimit.threshold_value)
}

// -------------------------------------------------------------------

// RiskState

// .botcore.trading.v1.RiskProfile profile = 1;
inline void RiskState::clear_profile() {
  _impl_.profile_ = 0;
}
inline ::botcore::trading::v1::RiskProfile RiskState::_internal_profile() const {
  return static_cast< ::botcore::trading::v1::RiskProfile >(_impl_.profile_);
}
inline ::botcore::trading::v1::RiskProfile RiskState::profile() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.profile)
  return _internal_profile();
}
inline void RiskState::_internal_set_profile(::botcore::trading::v1::RiskProfile value) {
  
  _impl_.profile_ = value;
}
inline void RiskState::set_profile(::botcore::trading::v1::RiskProfile value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RiskState.profile)
}

// double portfolio_value = 2;
inline void RiskState::clear_portfolio_value() {
  _impl_.portfolio_value_ = 0;
}
inline double RiskState::_internal_portfolio_value() const {
  return _impl_.portfolio_value_;
}
inline double RiskState::portfolio_value() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.portfolio_value)
  return _internal_portfolio_value();
}
inline void RiskState::_internal_set_portfolio_value(double value) {
  
  _impl_.portfolio_value_ = value;
}
inline void RiskState::set_portfolio_value(double value) {
  _internal_set_portfolio_value(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RiskState.portfolio_value)
}

// double current_drawdown = 3;
inline void RiskState::clear_current_drawdown() {
  _impl_.current_drawdown_ = 0;
}
inline double RiskState::_internal_current_drawdown() const {
  return _impl_.current_drawdown_;
}
inline double RiskState::current_drawdown() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.current_drawdown)
  return _internal_current_drawdown();
}
inline void RiskState::_internal_set_current_drawdown(double value) {
  
  _impl_.current_drawdown_ = value;
}
inline void RiskState::set_current_drawdown(double value) {
  _internal_set_current_drawdown(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RiskState.current_drawdown)
}

// double max_daily_loss = 4;
inline void RiskState::clear_max_daily_loss() {
  _impl_.max_daily_loss_ = 0;
}
inline double RiskState::_internal_max_daily_loss() const {
  return _impl_.max_daily_loss_;
}
inline double RiskState::max_daily_loss() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.max_daily_loss)
  return _internal_max_daily_loss();
}
inline void RiskState::_internal_set_max_daily_loss(double value) {
  
  _impl_.max_daily_loss_ = value;
}
inline void RiskState::set_max_daily_loss(double value) {
  _internal_set_max_daily_loss(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RiskState.max_daily_loss)
}

// double used_leverage = 5;
inline void RiskState::clear_used_leverage() {
  _impl_.used_leverage_ = 0;
}
inline double RiskState::_internal_used_leverage() const {
  return _impl_.used_leverage_;
}
inline double RiskState::used_leverage() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.used_leverage)
  return _internal_used_leverage();
}
inline void RiskState::_internal_set_used_leverage(double value) {
  
  _impl_.used_leverage_ = value;
}
inline void RiskState::set_used_leverage(double value) {
  _internal_set_used_leverage(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RiskState.used_leverage)
}

// repeated .botcore.trading.v1.ExposureLimit limits = 6;
inline int RiskState::_internal_limits_size() const {
  return _impl_.limits_.size();
}
inline int RiskState::limits_size() const {
  return _internal_limits_size();
}
inline void RiskState::clear_limits() {
  _impl_.limits_.Clear();
}
inline ::botcore::trading::v1::ExposureLimit* RiskState::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.RiskState.limits)
  return _impl_.limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::ExposureLimit >*
RiskState::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.RiskState.limits)
  return &_impl_.limits_;
}
inline const ::botcore::trading::v1::ExposureLimit& RiskState::_internal_limits(int index) const {
  return _impl_.limits_.Get(index);
}
inline const ::botcore::trading::v1::ExposureLimit& RiskState::limits(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.limits)
  return _internal_limits(index);
}
inline ::botcore::trading::v1::ExposureLimit* RiskState::_internal_add_limits() {
  return _impl_.limits_.Add();
}
inline ::botcore::trading::v1::ExposureLimit* RiskState::add_limits() {
  ::botcore::trading::v1::ExposureLimit* _add = _internal_add_limits();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.RiskState.limits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::ExposureLimit >&
RiskState::limits() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.RiskState.limits)
  return _impl_.limits_;
}

// .google.protobuf.Timestamp generated_at = 7;
inline bool RiskState::_internal_has_generated_at() const {
  return this != internal_default_instance() && _impl_.generated_at_ != nullptr;
}
inline bool RiskState::has_generated_at() const {
  return _internal_has_generated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RiskState::_internal_generated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.generated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RiskState::generated_at() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RiskState.generated_at)
  return _internal_generated_at();
}
inline void RiskState::unsafe_arena_set_allocated_generated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.generated_at_);
  }
  _impl_.generated_at_ = generated_at;
  if (generated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.RiskState.generated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RiskState::release_generated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.generated_at_;
  _impl_.generated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RiskState::unsafe_arena_release_generated_at() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.RiskState.generated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.generated_at_;
  _impl_.generated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RiskState::_internal_mutable_generated_at() {
  
  if (_impl_.generated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.generated_at_ = p;
  }
  return _impl_.generated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RiskState::mutable_generated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_generated_at();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.RiskState.generated_at)
  return _msg;
}
inline void RiskState::set_allocated_generated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.generated_at_);
  }
  if (generated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generated_at));
    if (message_arena != submessage_arena) {
      generated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.generated_at_ = generated_at;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.RiskState.generated_at)
}

// -------------------------------------------------------------------

// MetricsRequest

// bool include_ui_metrics = 1;
inline void MetricsRequest::clear_include_ui_metrics() {
  _impl_.include_ui_metrics_ = false;
}
inline bool MetricsRequest::_internal_include_ui_metrics() const {
  return _impl_.include_ui_metrics_;
}
inline bool MetricsRequest::include_ui_metrics() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsRequest.include_ui_metrics)
  return _internal_include_ui_metrics();
}
inline void MetricsRequest::_internal_set_include_ui_metrics(bool value) {
  
  _impl_.include_ui_metrics_ = value;
}
inline void MetricsRequest::set_include_ui_metrics(bool value) {
  _internal_set_include_ui_metrics(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsRequest.include_ui_metrics)
}

// -------------------------------------------------------------------

// MetricsSnapshot

// .google.protobuf.Timestamp generated_at = 1;
inline bool MetricsSnapshot::_internal_has_generated_at() const {
  return this != internal_default_instance() && _impl_.generated_at_ != nullptr;
}
inline bool MetricsSnapshot::has_generated_at() const {
  return _internal_has_generated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricsSnapshot::_internal_generated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.generated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricsSnapshot::generated_at() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.generated_at)
  return _internal_generated_at();
}
inline void MetricsSnapshot::unsafe_arena_set_allocated_generated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.generated_at_);
  }
  _impl_.generated_at_ = generated_at;
  if (generated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.MetricsSnapshot.generated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricsSnapshot::release_generated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.generated_at_;
  _impl_.generated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricsSnapshot::unsafe_arena_release_generated_at() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MetricsSnapshot.generated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.generated_at_;
  _impl_.generated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricsSnapshot::_internal_mutable_generated_at() {
  
  if (_impl_.generated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.generated_at_ = p;
  }
  return _impl_.generated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricsSnapshot::mutable_generated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_generated_at();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MetricsSnapshot.generated_at)
  return _msg;
}
inline void MetricsSnapshot::set_allocated_generated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* generated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.generated_at_);
  }
  if (generated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generated_at));
    if (message_arena != submessage_arena) {
      generated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.generated_at_ = generated_at;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MetricsSnapshot.generated_at)
}

// double event_to_frame_p95_ms = 2;
inline void MetricsSnapshot::clear_event_to_frame_p95_ms() {
  _impl_.event_to_frame_p95_ms_ = 0;
}
inline double MetricsSnapshot::_internal_event_to_frame_p95_ms() const {
  return _impl_.event_to_frame_p95_ms_;
}
inline double MetricsSnapshot::event_to_frame_p95_ms() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.event_to_frame_p95_ms)
  return _internal_event_to_frame_p95_ms();
}
inline void MetricsSnapshot::_internal_set_event_to_frame_p95_ms(double value) {
  
  _impl_.event_to_frame_p95_ms_ = value;
}
inline void MetricsSnapshot::set_event_to_frame_p95_ms(double value) {
  _internal_set_event_to_frame_p95_ms(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.event_to_frame_p95_ms)
}

// double fps = 3;
inline void MetricsSnapshot::clear_fps() {
  _impl_.fps_ = 0;
}
inline double MetricsSnapshot::_internal_fps() const {
  return _impl_.fps_;
}
inline double MetricsSnapshot::fps() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.fps)
  return _internal_fps();
}
inline void MetricsSnapshot::_internal_set_fps(double value) {
  
  _impl_.fps_ = value;
}
inline void MetricsSnapshot::set_fps(double value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.fps)
}

// double cpu_utilization = 4;
inline void MetricsSnapshot::clear_cpu_utilization() {
  _impl_.cpu_utilization_ = 0;
}
inline double MetricsSnapshot::_internal_cpu_utilization() const {
  return _impl_.cpu_utilization_;
}
inline double MetricsSnapshot::cpu_utilization() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.cpu_utilization)
  return _internal_cpu_utilization();
}
inline void MetricsSnapshot::_internal_set_cpu_utilization(double value) {
  
  _impl_.cpu_utilization_ = value;
}
inline void MetricsSnapshot::set_cpu_utilization(double value) {
  _internal_set_cpu_utilization(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.cpu_utilization)
}

// double gpu_utilization = 5;
inline void MetricsSnapshot::clear_gpu_utilization() {
  _impl_.gpu_utilization_ = 0;
}
inline double MetricsSnapshot::_internal_gpu_utilization() const {
  return _impl_.gpu_utilization_;
}
inline double MetricsSnapshot::gpu_utilization() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.gpu_utilization)
  return _internal_gpu_utilization();
}
inline void MetricsSnapshot::_internal_set_gpu_utilization(double value) {
  
  _impl_.gpu_utilization_ = value;
}
inline void MetricsSnapshot::set_gpu_utilization(double value) {
  _internal_set_gpu_utilization(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.gpu_utilization)
}

// double ram_megabytes = 6;
inline void MetricsSnapshot::clear_ram_megabytes() {
  _impl_.ram_megabytes_ = 0;
}
inline double MetricsSnapshot::_internal_ram_megabytes() const {
  return _impl_.ram_megabytes_;
}
inline double MetricsSnapshot::ram_megabytes() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.ram_megabytes)
  return _internal_ram_megabytes();
}
inline void MetricsSnapshot::_internal_set_ram_megabytes(double value) {
  
  _impl_.ram_megabytes_ = value;
}
inline void MetricsSnapshot::set_ram_megabytes(double value) {
  _internal_set_ram_megabytes(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.ram_megabytes)
}

// uint64 dropped_frames = 7;
inline void MetricsSnapshot::clear_dropped_frames() {
  _impl_.dropped_frames_ = uint64_t{0u};
}
inline uint64_t MetricsSnapshot::_internal_dropped_frames() const {
  return _impl_.dropped_frames_;
}
inline uint64_t MetricsSnapshot::dropped_frames() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.dropped_frames)
  return _internal_dropped_frames();
}
inline void MetricsSnapshot::_internal_set_dropped_frames(uint64_t value) {
  
  _impl_.dropped_frames_ = value;
}
inline void MetricsSnapshot::set_dropped_frames(uint64_t value) {
  _internal_set_dropped_frames(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.dropped_frames)
}

// uint64 processed_messages_per_second = 8;
inline void MetricsSnapshot::clear_processed_messages_per_second() {
  _impl_.processed_messages_per_second_ = uint64_t{0u};
}
inline uint64_t MetricsSnapshot::_internal_processed_messages_per_second() const {
  return _impl_.processed_messages_per_second_;
}
inline uint64_t MetricsSnapshot::processed_messages_per_second() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.processed_messages_per_second)
  return _internal_processed_messages_per_second();
}
inline void MetricsSnapshot::_internal_set_processed_messages_per_second(uint64_t value) {
  
  _impl_.processed_messages_per_second_ = value;
}
inline void MetricsSnapshot::set_processed_messages_per_second(uint64_t value) {
  _internal_set_processed_messages_per_second(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.processed_messages_per_second)
}

// string notes = 9;
inline void MetricsSnapshot::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& MetricsSnapshot::notes() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsSnapshot.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsSnapshot::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsSnapshot.notes)
}
inline std::string* MetricsSnapshot::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MetricsSnapshot.notes)
  return _s;
}
inline const std::string& MetricsSnapshot::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void MetricsSnapshot::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricsSnapshot::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricsSnapshot::release_notes() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MetricsSnapshot.notes)
  return _impl_.notes_.Release();
}
inline void MetricsSnapshot::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MetricsSnapshot.notes)
}

// -------------------------------------------------------------------

// MetricsAck

// bool accepted = 1;
inline void MetricsAck::clear_accepted() {
  _impl_.accepted_ = false;
}
inline bool MetricsAck::_internal_accepted() const {
  return _impl_.accepted_;
}
inline bool MetricsAck::accepted() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MetricsAck.accepted)
  return _internal_accepted();
}
inline void MetricsAck::_internal_set_accepted(bool value) {
  
  _impl_.accepted_ = value;
}
inline void MetricsAck::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MetricsAck.accepted)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// HealthCheckResponse

// string version = 1;
inline void HealthCheckResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::version() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.HealthCheckResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.HealthCheckResponse.version)
}
inline std::string* HealthCheckResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.HealthCheckResponse.version)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void HealthCheckResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_version() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.HealthCheckResponse.version)
  return _impl_.version_.Release();
}
inline void HealthCheckResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.HealthCheckResponse.version)
}

// string git_commit = 2;
inline void HealthCheckResponse::clear_git_commit() {
  _impl_.git_commit_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::git_commit() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.HealthCheckResponse.git_commit)
  return _internal_git_commit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_git_commit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.git_commit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.HealthCheckResponse.git_commit)
}
inline std::string* HealthCheckResponse::mutable_git_commit() {
  std::string* _s = _internal_mutable_git_commit();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.HealthCheckResponse.git_commit)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_git_commit() const {
  return _impl_.git_commit_.Get();
}
inline void HealthCheckResponse::_internal_set_git_commit(const std::string& value) {
  
  _impl_.git_commit_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_git_commit() {
  
  return _impl_.git_commit_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_git_commit() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.HealthCheckResponse.git_commit)
  return _impl_.git_commit_.Release();
}
inline void HealthCheckResponse::set_allocated_git_commit(std::string* git_commit) {
  if (git_commit != nullptr) {
    
  } else {
    
  }
  _impl_.git_commit_.SetAllocated(git_commit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.git_commit_.IsDefault()) {
    _impl_.git_commit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.HealthCheckResponse.git_commit)
}

// .google.protobuf.Timestamp started_at = 3;
inline bool HealthCheckResponse::_internal_has_started_at() const {
  return this != internal_default_instance() && _impl_.started_at_ != nullptr;
}
inline bool HealthCheckResponse::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::started_at() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.HealthCheckResponse.started_at)
  return _internal_started_at();
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  _impl_.started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.HealthCheckResponse.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::release_started_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.HealthCheckResponse.started_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::_internal_mutable_started_at() {
  
  if (_impl_.started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.started_at_ = p;
  }
  return _impl_.started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.HealthCheckResponse.started_at)
  return _msg;
}
inline void HealthCheckResponse::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.HealthCheckResponse.started_at)
}

// -------------------------------------------------------------------

// MarketplacePresetSummary

// string preset_id = 1;
inline void MarketplacePresetSummary::clear_preset_id() {
  _impl_.preset_id_.ClearToEmpty();
}
inline const std::string& MarketplacePresetSummary::preset_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.preset_id)
  return _internal_preset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketplacePresetSummary::set_preset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.preset_id)
}
inline std::string* MarketplacePresetSummary::mutable_preset_id() {
  std::string* _s = _internal_mutable_preset_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.preset_id)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_preset_id() const {
  return _impl_.preset_id_.Get();
}
inline void MarketplacePresetSummary::_internal_set_preset_id(const std::string& value) {
  
  _impl_.preset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::_internal_mutable_preset_id() {
  
  return _impl_.preset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::release_preset_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MarketplacePresetSummary.preset_id)
  return _impl_.preset_id_.Release();
}
inline void MarketplacePresetSummary::set_allocated_preset_id(std::string* preset_id) {
  if (preset_id != nullptr) {
    
  } else {
    
  }
  _impl_.preset_id_.SetAllocated(preset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preset_id_.IsDefault()) {
    _impl_.preset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MarketplacePresetSummary.preset_id)
}

// string name = 2;
inline void MarketplacePresetSummary::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MarketplacePresetSummary::name() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketplacePresetSummary::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.name)
}
inline std::string* MarketplacePresetSummary::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.name)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MarketplacePresetSummary::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::release_name() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MarketplacePresetSummary.name)
  return _impl_.name_.Release();
}
inline void MarketplacePresetSummary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MarketplacePresetSummary.name)
}

// string version = 3;
inline void MarketplacePresetSummary::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MarketplacePresetSummary::version() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketplacePresetSummary::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.version)
}
inline std::string* MarketplacePresetSummary::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.version)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MarketplacePresetSummary::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::release_version() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MarketplacePresetSummary.version)
  return _impl_.version_.Release();
}
inline void MarketplacePresetSummary::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MarketplacePresetSummary.version)
}

// string profile = 4;
inline void MarketplacePresetSummary::clear_profile() {
  _impl_.profile_.ClearToEmpty();
}
inline const std::string& MarketplacePresetSummary::profile() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.profile)
  return _internal_profile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketplacePresetSummary::set_profile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.profile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.profile)
}
inline std::string* MarketplacePresetSummary::mutable_profile() {
  std::string* _s = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.profile)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_profile() const {
  return _impl_.profile_.Get();
}
inline void MarketplacePresetSummary::_internal_set_profile(const std::string& value) {
  
  _impl_.profile_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::_internal_mutable_profile() {
  
  return _impl_.profile_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::release_profile() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MarketplacePresetSummary.profile)
  return _impl_.profile_.Release();
}
inline void MarketplacePresetSummary::set_allocated_profile(std::string* profile) {
  if (profile != nullptr) {
    
  } else {
    
  }
  _impl_.profile_.SetAllocated(profile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profile_.IsDefault()) {
    _impl_.profile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MarketplacePresetSummary.profile)
}

// repeated string tags = 5;
inline int MarketplacePresetSummary::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int MarketplacePresetSummary::tags_size() const {
  return _internal_tags_size();
}
inline void MarketplacePresetSummary::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* MarketplacePresetSummary::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:botcore.trading.v1.MarketplacePresetSummary.tags)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& MarketplacePresetSummary::tags(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.tags)
  return _internal_tags(index);
}
inline std::string* MarketplacePresetSummary::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.tags)
  return _impl_.tags_.Mutable(index);
}
inline void MarketplacePresetSummary::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline std::string* MarketplacePresetSummary::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void MarketplacePresetSummary::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline void MarketplacePresetSummary::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:botcore.trading.v1.MarketplacePresetSummary.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MarketplacePresetSummary::tags() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.MarketplacePresetSummary.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MarketplacePresetSummary::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.MarketplacePresetSummary.tags)
  return &_impl_.tags_;
}

// bool signature_verified = 6;
inline void MarketplacePresetSummary::clear_signature_verified() {
  _impl_.signature_verified_ = false;
}
inline bool MarketplacePresetSummary::_internal_signature_verified() const {
  return _impl_.signature_verified_;
}
inline bool MarketplacePresetSummary::signature_verified() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.signature_verified)
  return _internal_signature_verified();
}
inline void MarketplacePresetSummary::_internal_set_signature_verified(bool value) {
  
  _impl_.signature_verified_ = value;
}
inline void MarketplacePresetSummary::set_signature_verified(bool value) {
  _internal_set_signature_verified(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.signature_verified)
}

// string source_path = 7;
inline void MarketplacePresetSummary::clear_source_path() {
  _impl_.source_path_.ClearToEmpty();
}
inline const std::string& MarketplacePresetSummary::source_path() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.source_path)
  return _internal_source_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketplacePresetSummary::set_source_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.source_path)
}
inline std::string* MarketplacePresetSummary::mutable_source_path() {
  std::string* _s = _internal_mutable_source_path();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.source_path)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_source_path() const {
  return _impl_.source_path_.Get();
}
inline void MarketplacePresetSummary::_internal_set_source_path(const std::string& value) {
  
  _impl_.source_path_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::_internal_mutable_source_path() {
  
  return _impl_.source_path_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketplacePresetSummary::release_source_path() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.MarketplacePresetSummary.source_path)
  return _impl_.source_path_.Release();
}
inline void MarketplacePresetSummary::set_allocated_source_path(std::string* source_path) {
  if (source_path != nullptr) {
    
  } else {
    
  }
  _impl_.source_path_.SetAllocated(source_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_path_.IsDefault()) {
    _impl_.source_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.MarketplacePresetSummary.source_path)
}

// repeated string issues = 8;
inline int MarketplacePresetSummary::_internal_issues_size() const {
  return _impl_.issues_.size();
}
inline int MarketplacePresetSummary::issues_size() const {
  return _internal_issues_size();
}
inline void MarketplacePresetSummary::clear_issues() {
  _impl_.issues_.Clear();
}
inline std::string* MarketplacePresetSummary::add_issues() {
  std::string* _s = _internal_add_issues();
  // @@protoc_insertion_point(field_add_mutable:botcore.trading.v1.MarketplacePresetSummary.issues)
  return _s;
}
inline const std::string& MarketplacePresetSummary::_internal_issues(int index) const {
  return _impl_.issues_.Get(index);
}
inline const std::string& MarketplacePresetSummary::issues(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.MarketplacePresetSummary.issues)
  return _internal_issues(index);
}
inline std::string* MarketplacePresetSummary::mutable_issues(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.MarketplacePresetSummary.issues)
  return _impl_.issues_.Mutable(index);
}
inline void MarketplacePresetSummary::set_issues(int index, const std::string& value) {
  _impl_.issues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::set_issues(int index, std::string&& value) {
  _impl_.issues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::set_issues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.issues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::set_issues(int index, const char* value, size_t size) {
  _impl_.issues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline std::string* MarketplacePresetSummary::_internal_add_issues() {
  return _impl_.issues_.Add();
}
inline void MarketplacePresetSummary::add_issues(const std::string& value) {
  _impl_.issues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::add_issues(std::string&& value) {
  _impl_.issues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::add_issues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.issues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline void MarketplacePresetSummary::add_issues(const char* value, size_t size) {
  _impl_.issues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:botcore.trading.v1.MarketplacePresetSummary.issues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MarketplacePresetSummary::issues() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.MarketplacePresetSummary.issues)
  return _impl_.issues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MarketplacePresetSummary::mutable_issues() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.MarketplacePresetSummary.issues)
  return &_impl_.issues_;
}

// -------------------------------------------------------------------

// ListMarketplacePresetsRequest

// -------------------------------------------------------------------

// ListMarketplacePresetsResponse

// repeated .botcore.trading.v1.MarketplacePresetSummary presets = 1;
inline int ListMarketplacePresetsResponse::_internal_presets_size() const {
  return _impl_.presets_.size();
}
inline int ListMarketplacePresetsResponse::presets_size() const {
  return _internal_presets_size();
}
inline void ListMarketplacePresetsResponse::clear_presets() {
  _impl_.presets_.Clear();
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ListMarketplacePresetsResponse::mutable_presets(int index) {
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ListMarketplacePresetsResponse.presets)
  return _impl_.presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::MarketplacePresetSummary >*
ListMarketplacePresetsResponse::mutable_presets() {
  // @@protoc_insertion_point(field_mutable_list:botcore.trading.v1.ListMarketplacePresetsResponse.presets)
  return &_impl_.presets_;
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ListMarketplacePresetsResponse::_internal_presets(int index) const {
  return _impl_.presets_.Get(index);
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ListMarketplacePresetsResponse::presets(int index) const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ListMarketplacePresetsResponse.presets)
  return _internal_presets(index);
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ListMarketplacePresetsResponse::_internal_add_presets() {
  return _impl_.presets_.Add();
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ListMarketplacePresetsResponse::add_presets() {
  ::botcore::trading::v1::MarketplacePresetSummary* _add = _internal_add_presets();
  // @@protoc_insertion_point(field_add:botcore.trading.v1.ListMarketplacePresetsResponse.presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::botcore::trading::v1::MarketplacePresetSummary >&
ListMarketplacePresetsResponse::presets() const {
  // @@protoc_insertion_point(field_list:botcore.trading.v1.ListMarketplacePresetsResponse.presets)
  return _impl_.presets_;
}

// -------------------------------------------------------------------

// ImportMarketplacePresetRequest

// bytes payload = 1;
inline void ImportMarketplacePresetRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& ImportMarketplacePresetRequest::payload() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ImportMarketplacePresetRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportMarketplacePresetRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ImportMarketplacePresetRequest.payload)
}
inline std::string* ImportMarketplacePresetRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ImportMarketplacePresetRequest.payload)
  return _s;
}
inline const std::string& ImportMarketplacePresetRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void ImportMarketplacePresetRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportMarketplacePresetRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportMarketplacePresetRequest::release_payload() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ImportMarketplacePresetRequest.payload)
  return _impl_.payload_.Release();
}
inline void ImportMarketplacePresetRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ImportMarketplacePresetRequest.payload)
}

// string filename = 2;
inline void ImportMarketplacePresetRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& ImportMarketplacePresetRequest::filename() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ImportMarketplacePresetRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportMarketplacePresetRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ImportMarketplacePresetRequest.filename)
}
inline std::string* ImportMarketplacePresetRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ImportMarketplacePresetRequest.filename)
  return _s;
}
inline const std::string& ImportMarketplacePresetRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void ImportMarketplacePresetRequest::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportMarketplacePresetRequest::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportMarketplacePresetRequest::release_filename() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ImportMarketplacePresetRequest.filename)
  return _impl_.filename_.Release();
}
inline void ImportMarketplacePresetRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ImportMarketplacePresetRequest.filename)
}

// -------------------------------------------------------------------

// ImportMarketplacePresetResponse

// .botcore.trading.v1.MarketplacePresetSummary preset = 1;
inline bool ImportMarketplacePresetResponse::_internal_has_preset() const {
  return this != internal_default_instance() && _impl_.preset_ != nullptr;
}
inline bool ImportMarketplacePresetResponse::has_preset() const {
  return _internal_has_preset();
}
inline void ImportMarketplacePresetResponse::clear_preset() {
  if (GetArenaForAllocation() == nullptr && _impl_.preset_ != nullptr) {
    delete _impl_.preset_;
  }
  _impl_.preset_ = nullptr;
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ImportMarketplacePresetResponse::_internal_preset() const {
  const ::botcore::trading::v1::MarketplacePresetSummary* p = _impl_.preset_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::MarketplacePresetSummary&>(
      ::botcore::trading::v1::_MarketplacePresetSummary_default_instance_);
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ImportMarketplacePresetResponse::preset() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ImportMarketplacePresetResponse.preset)
  return _internal_preset();
}
inline void ImportMarketplacePresetResponse::unsafe_arena_set_allocated_preset(
    ::botcore::trading::v1::MarketplacePresetSummary* preset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preset_);
  }
  _impl_.preset_ = preset;
  if (preset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.ImportMarketplacePresetResponse.preset)
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ImportMarketplacePresetResponse::release_preset() {
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ImportMarketplacePresetResponse::unsafe_arena_release_preset() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ImportMarketplacePresetResponse.preset)
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ImportMarketplacePresetResponse::_internal_mutable_preset() {
  
  if (_impl_.preset_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::MarketplacePresetSummary>(GetArenaForAllocation());
    _impl_.preset_ = p;
  }
  return _impl_.preset_;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ImportMarketplacePresetResponse::mutable_preset() {
  ::botcore::trading::v1::MarketplacePresetSummary* _msg = _internal_mutable_preset();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ImportMarketplacePresetResponse.preset)
  return _msg;
}
inline void ImportMarketplacePresetResponse::set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preset_;
  }
  if (preset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preset);
    if (message_arena != submessage_arena) {
      preset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.preset_ = preset;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ImportMarketplacePresetResponse.preset)
}

// -------------------------------------------------------------------

// ExportMarketplacePresetRequest

// string preset_id = 1;
inline void ExportMarketplacePresetRequest::clear_preset_id() {
  _impl_.preset_id_.ClearToEmpty();
}
inline const std::string& ExportMarketplacePresetRequest::preset_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetRequest.preset_id)
  return _internal_preset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportMarketplacePresetRequest::set_preset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExportMarketplacePresetRequest.preset_id)
}
inline std::string* ExportMarketplacePresetRequest::mutable_preset_id() {
  std::string* _s = _internal_mutable_preset_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetRequest.preset_id)
  return _s;
}
inline const std::string& ExportMarketplacePresetRequest::_internal_preset_id() const {
  return _impl_.preset_id_.Get();
}
inline void ExportMarketplacePresetRequest::_internal_set_preset_id(const std::string& value) {
  
  _impl_.preset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetRequest::_internal_mutable_preset_id() {
  
  return _impl_.preset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetRequest::release_preset_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetRequest.preset_id)
  return _impl_.preset_id_.Release();
}
inline void ExportMarketplacePresetRequest::set_allocated_preset_id(std::string* preset_id) {
  if (preset_id != nullptr) {
    
  } else {
    
  }
  _impl_.preset_id_.SetAllocated(preset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preset_id_.IsDefault()) {
    _impl_.preset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetRequest.preset_id)
}

// string format = 2;
inline void ExportMarketplacePresetRequest::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& ExportMarketplacePresetRequest::format() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetRequest.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportMarketplacePresetRequest::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExportMarketplacePresetRequest.format)
}
inline std::string* ExportMarketplacePresetRequest::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetRequest.format)
  return _s;
}
inline const std::string& ExportMarketplacePresetRequest::_internal_format() const {
  return _impl_.format_.Get();
}
inline void ExportMarketplacePresetRequest::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetRequest::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetRequest::release_format() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetRequest.format)
  return _impl_.format_.Release();
}
inline void ExportMarketplacePresetRequest::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetRequest.format)
}

// -------------------------------------------------------------------

// ExportMarketplacePresetResponse

// bytes payload = 1;
inline void ExportMarketplacePresetResponse::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& ExportMarketplacePresetResponse::payload() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetResponse.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportMarketplacePresetResponse::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExportMarketplacePresetResponse.payload)
}
inline std::string* ExportMarketplacePresetResponse::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetResponse.payload)
  return _s;
}
inline const std::string& ExportMarketplacePresetResponse::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void ExportMarketplacePresetResponse::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::release_payload() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetResponse.payload)
  return _impl_.payload_.Release();
}
inline void ExportMarketplacePresetResponse::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetResponse.payload)
}

// string filename = 2;
inline void ExportMarketplacePresetResponse::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& ExportMarketplacePresetResponse::filename() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetResponse.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportMarketplacePresetResponse::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExportMarketplacePresetResponse.filename)
}
inline std::string* ExportMarketplacePresetResponse::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetResponse.filename)
  return _s;
}
inline const std::string& ExportMarketplacePresetResponse::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void ExportMarketplacePresetResponse::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::release_filename() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetResponse.filename)
  return _impl_.filename_.Release();
}
inline void ExportMarketplacePresetResponse::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetResponse.filename)
}

// .botcore.trading.v1.MarketplacePresetSummary preset = 3;
inline bool ExportMarketplacePresetResponse::_internal_has_preset() const {
  return this != internal_default_instance() && _impl_.preset_ != nullptr;
}
inline bool ExportMarketplacePresetResponse::has_preset() const {
  return _internal_has_preset();
}
inline void ExportMarketplacePresetResponse::clear_preset() {
  if (GetArenaForAllocation() == nullptr && _impl_.preset_ != nullptr) {
    delete _impl_.preset_;
  }
  _impl_.preset_ = nullptr;
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ExportMarketplacePresetResponse::_internal_preset() const {
  const ::botcore::trading::v1::MarketplacePresetSummary* p = _impl_.preset_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::MarketplacePresetSummary&>(
      ::botcore::trading::v1::_MarketplacePresetSummary_default_instance_);
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ExportMarketplacePresetResponse::preset() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetResponse.preset)
  return _internal_preset();
}
inline void ExportMarketplacePresetResponse::unsafe_arena_set_allocated_preset(
    ::botcore::trading::v1::MarketplacePresetSummary* preset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preset_);
  }
  _impl_.preset_ = preset;
  if (preset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.ExportMarketplacePresetResponse.preset)
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ExportMarketplacePresetResponse::release_preset() {
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ExportMarketplacePresetResponse::unsafe_arena_release_preset() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetResponse.preset)
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ExportMarketplacePresetResponse::_internal_mutable_preset() {
  
  if (_impl_.preset_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::MarketplacePresetSummary>(GetArenaForAllocation());
    _impl_.preset_ = p;
  }
  return _impl_.preset_;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ExportMarketplacePresetResponse::mutable_preset() {
  ::botcore::trading::v1::MarketplacePresetSummary* _msg = _internal_mutable_preset();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetResponse.preset)
  return _msg;
}
inline void ExportMarketplacePresetResponse::set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preset_;
  }
  if (preset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preset);
    if (message_arena != submessage_arena) {
      preset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.preset_ = preset;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetResponse.preset)
}

// string format = 4;
inline void ExportMarketplacePresetResponse::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& ExportMarketplacePresetResponse::format() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ExportMarketplacePresetResponse.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportMarketplacePresetResponse::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ExportMarketplacePresetResponse.format)
}
inline std::string* ExportMarketplacePresetResponse::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ExportMarketplacePresetResponse.format)
  return _s;
}
inline const std::string& ExportMarketplacePresetResponse::_internal_format() const {
  return _impl_.format_.Get();
}
inline void ExportMarketplacePresetResponse::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportMarketplacePresetResponse::release_format() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ExportMarketplacePresetResponse.format)
  return _impl_.format_.Release();
}
inline void ExportMarketplacePresetResponse::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ExportMarketplacePresetResponse.format)
}

// -------------------------------------------------------------------

// RemoveMarketplacePresetRequest

// string preset_id = 1;
inline void RemoveMarketplacePresetRequest::clear_preset_id() {
  _impl_.preset_id_.ClearToEmpty();
}
inline const std::string& RemoveMarketplacePresetRequest::preset_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RemoveMarketplacePresetRequest.preset_id)
  return _internal_preset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveMarketplacePresetRequest::set_preset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RemoveMarketplacePresetRequest.preset_id)
}
inline std::string* RemoveMarketplacePresetRequest::mutable_preset_id() {
  std::string* _s = _internal_mutable_preset_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.RemoveMarketplacePresetRequest.preset_id)
  return _s;
}
inline const std::string& RemoveMarketplacePresetRequest::_internal_preset_id() const {
  return _impl_.preset_id_.Get();
}
inline void RemoveMarketplacePresetRequest::_internal_set_preset_id(const std::string& value) {
  
  _impl_.preset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveMarketplacePresetRequest::_internal_mutable_preset_id() {
  
  return _impl_.preset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveMarketplacePresetRequest::release_preset_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.RemoveMarketplacePresetRequest.preset_id)
  return _impl_.preset_id_.Release();
}
inline void RemoveMarketplacePresetRequest::set_allocated_preset_id(std::string* preset_id) {
  if (preset_id != nullptr) {
    
  } else {
    
  }
  _impl_.preset_id_.SetAllocated(preset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preset_id_.IsDefault()) {
    _impl_.preset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.RemoveMarketplacePresetRequest.preset_id)
}

// -------------------------------------------------------------------

// RemoveMarketplacePresetResponse

// bool removed = 1;
inline void RemoveMarketplacePresetResponse::clear_removed() {
  _impl_.removed_ = false;
}
inline bool RemoveMarketplacePresetResponse::_internal_removed() const {
  return _impl_.removed_;
}
inline bool RemoveMarketplacePresetResponse::removed() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.RemoveMarketplacePresetResponse.removed)
  return _internal_removed();
}
inline void RemoveMarketplacePresetResponse::_internal_set_removed(bool value) {
  
  _impl_.removed_ = value;
}
inline void RemoveMarketplacePresetResponse::set_removed(bool value) {
  _internal_set_removed(value);
  // @@protoc_insertion_point(field_set:botcore.trading.v1.RemoveMarketplacePresetResponse.removed)
}

// -------------------------------------------------------------------

// ActivateMarketplacePresetRequest

// string preset_id = 1;
inline void ActivateMarketplacePresetRequest::clear_preset_id() {
  _impl_.preset_id_.ClearToEmpty();
}
inline const std::string& ActivateMarketplacePresetRequest::preset_id() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ActivateMarketplacePresetRequest.preset_id)
  return _internal_preset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActivateMarketplacePresetRequest::set_preset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:botcore.trading.v1.ActivateMarketplacePresetRequest.preset_id)
}
inline std::string* ActivateMarketplacePresetRequest::mutable_preset_id() {
  std::string* _s = _internal_mutable_preset_id();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ActivateMarketplacePresetRequest.preset_id)
  return _s;
}
inline const std::string& ActivateMarketplacePresetRequest::_internal_preset_id() const {
  return _impl_.preset_id_.Get();
}
inline void ActivateMarketplacePresetRequest::_internal_set_preset_id(const std::string& value) {
  
  _impl_.preset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivateMarketplacePresetRequest::_internal_mutable_preset_id() {
  
  return _impl_.preset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActivateMarketplacePresetRequest::release_preset_id() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ActivateMarketplacePresetRequest.preset_id)
  return _impl_.preset_id_.Release();
}
inline void ActivateMarketplacePresetRequest::set_allocated_preset_id(std::string* preset_id) {
  if (preset_id != nullptr) {
    
  } else {
    
  }
  _impl_.preset_id_.SetAllocated(preset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preset_id_.IsDefault()) {
    _impl_.preset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ActivateMarketplacePresetRequest.preset_id)
}

// -------------------------------------------------------------------

// ActivateMarketplacePresetResponse

// .botcore.trading.v1.MarketplacePresetSummary preset = 1;
inline bool ActivateMarketplacePresetResponse::_internal_has_preset() const {
  return this != internal_default_instance() && _impl_.preset_ != nullptr;
}
inline bool ActivateMarketplacePresetResponse::has_preset() const {
  return _internal_has_preset();
}
inline void ActivateMarketplacePresetResponse::clear_preset() {
  if (GetArenaForAllocation() == nullptr && _impl_.preset_ != nullptr) {
    delete _impl_.preset_;
  }
  _impl_.preset_ = nullptr;
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ActivateMarketplacePresetResponse::_internal_preset() const {
  const ::botcore::trading::v1::MarketplacePresetSummary* p = _impl_.preset_;
  return p != nullptr ? *p : reinterpret_cast<const ::botcore::trading::v1::MarketplacePresetSummary&>(
      ::botcore::trading::v1::_MarketplacePresetSummary_default_instance_);
}
inline const ::botcore::trading::v1::MarketplacePresetSummary& ActivateMarketplacePresetResponse::preset() const {
  // @@protoc_insertion_point(field_get:botcore.trading.v1.ActivateMarketplacePresetResponse.preset)
  return _internal_preset();
}
inline void ActivateMarketplacePresetResponse::unsafe_arena_set_allocated_preset(
    ::botcore::trading::v1::MarketplacePresetSummary* preset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preset_);
  }
  _impl_.preset_ = preset;
  if (preset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:botcore.trading.v1.ActivateMarketplacePresetResponse.preset)
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ActivateMarketplacePresetResponse::release_preset() {
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ActivateMarketplacePresetResponse::unsafe_arena_release_preset() {
  // @@protoc_insertion_point(field_release:botcore.trading.v1.ActivateMarketplacePresetResponse.preset)
  
  ::botcore::trading::v1::MarketplacePresetSummary* temp = _impl_.preset_;
  _impl_.preset_ = nullptr;
  return temp;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ActivateMarketplacePresetResponse::_internal_mutable_preset() {
  
  if (_impl_.preset_ == nullptr) {
    auto* p = CreateMaybeMessage<::botcore::trading::v1::MarketplacePresetSummary>(GetArenaForAllocation());
    _impl_.preset_ = p;
  }
  return _impl_.preset_;
}
inline ::botcore::trading::v1::MarketplacePresetSummary* ActivateMarketplacePresetResponse::mutable_preset() {
  ::botcore::trading::v1::MarketplacePresetSummary* _msg = _internal_mutable_preset();
  // @@protoc_insertion_point(field_mutable:botcore.trading.v1.ActivateMarketplacePresetResponse.preset)
  return _msg;
}
inline void ActivateMarketplacePresetResponse::set_allocated_preset(::botcore::trading::v1::MarketplacePresetSummary* preset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preset_;
  }
  if (preset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preset);
    if (message_arena != submessage_arena) {
      preset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.preset_ = preset;
  // @@protoc_insertion_point(field_set_allocated:botcore.trading.v1.ActivateMarketplacePresetResponse.preset)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace trading
}  // namespace botcore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::botcore::trading::v1::OrderSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botcore::trading::v1::OrderSide>() {
  return ::botcore::trading::v1::OrderSide_descriptor();
}
template <> struct is_proto_enum< ::botcore::trading::v1::OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botcore::trading::v1::OrderType>() {
  return ::botcore::trading::v1::OrderType_descriptor();
}
template <> struct is_proto_enum< ::botcore::trading::v1::TimeInForce> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botcore::trading::v1::TimeInForce>() {
  return ::botcore::trading::v1::TimeInForce_descriptor();
}
template <> struct is_proto_enum< ::botcore::trading::v1::RiskProfile> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botcore::trading::v1::RiskProfile>() {
  return ::botcore::trading::v1::RiskProfile_descriptor();
}
template <> struct is_proto_enum< ::botcore::trading::v1::OrderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botcore::trading::v1::OrderStatus>() {
  return ::botcore::trading::v1::OrderStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_trading_2eproto
